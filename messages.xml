<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:noNamespaceSchemaLocation="http://findsecbugs.h3xstream.com/messagecollection.xsd">

    <Plugin>
        <ShortDescription>Find Security Bugs</ShortDescription>
        <Details>Find Security Bugs是一个旨在帮助安全审计的插件。</Details>
        <BugsUrl>http://find-sec-bugs.github.io/bugs.htm</BugsUrl>
        <AllBugsUrl>http://find-sec-bugs.github.io/bugs.htm</AllBugsUrl>
    </Plugin>

    <!-- Predictable Pseudo Random Generator (PRG) -->
    <Detector class="com.h3xstream.findsecbugs.PredictableRandomDetector">
        <Details>识别可预测的伪随机值生成器的使用 (PRG).
        </Details>
    </Detector>

    <BugPattern type="PREDICTABLE_RANDOM">
        <ShortDescription>可预测的伪随机数生成器</ShortDescription>
        <LongDescription>{3}的使用是可预测的</LongDescription>
        <Details>
            <![CDATA[
<p>在某些安全关键的环境中，使用可预测的伪随机值可能会导致漏洞。例如, 当伪随机值作为:</p>
<ul>
<li>CSRF令牌: 可预测的令牌可能导致CSRF攻击，因为攻击者将会知道令牌的值</li>
<li>密码重置令牌(通过邮件发送): 可预测的密码令牌可能导致账号被接管, 因为攻击者会猜测更改密码表单的URL</li>
<li>其他秘密值</li>
</ul>
<p>
可以将 <b>java.util.Random</b> 替换成其他更强大的类, 例如 <b>java.security.SecureRandom</b> 来快速修复这个问题。
</p>
<p>
<b>缺陷代码:</b><br/>
<pre>String generateSecretToken() {
    Random r = new Random();
    return Long.toHexString(r.nextLong());
}</pre>
</p>
<p>
<b>解决方案:</b>
<pre>import org.apache.commons.codec.binary.Hex;

String generateSecretToken() {
    SecureRandom secRandom = new SecureRandom();

    byte[] result = new byte[32];
    secRandom.nextBytes(result);
    return Hex.encodeHexString(result);
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br/>
<a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers">CERT: MSC02-J. Generate strong random numbers</a><br/>
<a href="http://cwe.mitre.org/data/definitions/330.html">CWE-330: Use of Insufficiently Random Values</a><br/>
<a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPR">可预测的伪随机值生成器</BugCode>

    <BugPattern type="PREDICTABLE_RANDOM_SCALA">
        <ShortDescription>可预测的伪随机数生成器 (Scala)</ShortDescription>
        <LongDescription>{3}的使用是可预测的</LongDescription>
        <Details>
            <![CDATA[
<p>在某些安全关键的环境中，使用可预测的伪随机值可能会导致漏洞. 例如, 当伪随机值作为:</p>
<ul>
<li>CSRF令牌: 可预测的令牌可能导致CSRF攻击，因为攻击者将会知道令牌的值</li>
<li>密码重置令牌(通过邮件发送): 可预测的密码令牌可能导致账号被接管, 因为攻击者会猜测更改密码表单的URL</li>
<li>其他秘密值</li>
</ul>
<p>
可以将 <b>java.util.Random</b> 替换成其他更强大的类, 例如 <b>java.security.SecureRandom</b> 来快速修复这个问题。
</p>
<p>
<b>缺陷代码:</b><br/>
<pre>import scala.util.Random

def generateSecretToken() {
    val result = Seq.fill(16)(Random.nextInt)
    return result.map("%02x" format _).mkString
}</pre>
</p>
<p>
    <b>解决方案:</b>
<pre>import java.security.SecureRandom

def generateSecretToken() {
    val rand = new SecureRandom()
    val value = Array.ofDim[Byte](16)
    rand.nextBytes(value)
    return value.map("%02x" format _).mkString
}</pre>
</p>
<!--<p>
<b>解决方案:</b>
<pre>import java.security.SecureRandom
import scala.util.Random._

def generateSecretToken() {
    val secRandom = javaRandomToRandom(new SecureRandom())
    val result = Seq.fill(16)(secRandom.nextInt)
    return result.map("%02x" format _).mkString
}</pre>
</p>-->
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br/>
<a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers">CERT: MSC02-J. Generate strong random numbers</a><br/>
<a href="http://cwe.mitre.org/data/definitions/330.html">CWE-330: Use of Insufficiently Random Values</a><br/>
<a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPRS">可预测的伪随机值生成器 (Scala)</BugCode>

    <!-- Servlet parameter -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.ServletEndpointDetector">
        <Details>识别来自ServletRequest和HttpServletRequest的未过滤值。
        </Details>
    </Detector>

    <BugPattern type="SERVLET_PARAMETER">
        <ShortDescription>不受信任的servlet参数</ShortDescription>
        <LongDescription>方法 {3} 返回由客户端控制的String值</LongDescription>
        <Details>
            <![CDATA[
<p>Servlet可以通过多种方法读取GET和POST参数。获得的值应视为不安全的。
在将这些值传递给如下敏感的API之前，您可能需要验证或者净化它们:</p>
<ul>
<li>SQL查询(可能导致SQL注入)</li>
<li>打开文件(可能导致路径遍历)</li>
<li>命令执行(潜在的命令注入)</li>
<li>构造HTML(潜在的XSS)</li>
<li>等等...</li>
</ul>

<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSP">Servlet参数</BugCode>


    <BugPattern type="SERVLET_CONTENT_TYPE">
        <ShortDescription>不被信任的Content-Type标头</ShortDescription>
        <LongDescription>HTTP的Content-Type标头可以由客户端控制</LongDescription>
        <Details>
            <![CDATA[
<p>
HTTP的Content-Type标头可以由客户端控制。 因此，请勿将该值用于安全关键决策。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSCT">Content-Type标头</BugCode>


    <BugPattern type="SERVLET_SERVER_NAME">
        <ShortDescription>不被信任的Hostname标头</ShortDescription>
        <LongDescription>收到的主机名通常可以被客户端控制</LongDescription>
        <Details>
            <![CDATA[
<p>Hostname标头可以被客户端控制。 因此，请勿将该值用于安全关键决策。
<code>ServletRequest.getServerName()</code> 和 <code>HttpServletRequest.getHeader("Host")</code> 提取 <code>Host</code> 标头的行为是一样的。</p>
<pre>
GET /testpage HTTP/1.1
Host: www.example.com
[...]</pre>
<p>
为您的应用程序服务的Web容器可以默认地将请求重定向到您的应用程序。 这将允许恶意用户在Host头中放置任何值。
建议您不要在对请求作出的任何安全决策中信任该值。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSN">不被信任的Hostname标头</BugCode>


    <BugPattern type="SERVLET_SESSION_ID">
        <ShortDescription>不受信任的会话cookie值</ShortDescription>
        <LongDescription>应避免直接访问会话ID</LongDescription>
        <Details>
            <![CDATA[
<p>
方法 <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()"><code>HttpServletRequest.getRequestedSessionId()</code></a>
通常返回cookie <code>JSESSIONID</code> 的值。 该值通常仅由会话管理逻辑访问，而不是常规的开发人员代码。
</p>
<p>
传递给客户端的值通常是字母数字值 (例如, <code>JSESSIONID=jp6q31lq2myn</code>)。然而, 该值可以被客户端更改。
以下HTTP请求显示了其潜在更改的示例。
<pre>
GET /somePage HTTP/1.1
Host: yourwebsite.com
User-Agent: Mozilla/5.0
Cookie: JSESSIONID=Any value of the user&#39;s choice!!??'''&quot;&gt;
</pre>
</p>
<p>因此, JSESSIONID只应用于查看其值是否与现有会话ID匹配。如果不匹配, 应将该用户视为未经身份验证的用户。并且，永远不应记录会话ID值。
 如果匹配, 那么日志文件可以包含有效的活动会话ID, 以允许内部人员拦截ID已被记录并仍然活动的任何会话。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet">OWASP: Session Management Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>

</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSID">会话Cookie值</BugCode>


    <BugPattern type="SERVLET_QUERY_STRING">
        <ShortDescription>不受信任的查询字符串</ShortDescription>
        <LongDescription>查询字符串可以是任何值</LongDescription>
        <Details>
            <![CDATA[
<p>查询字符串是GET参数名称和值的串联。 可以传入预期参数以外的任何内容。</p>
<p>对于URL请求<code> /app/servlet.htm?a=1&b=2 </ code>，查询字符串将为<code> a = 1＆b = 2 </ code></p>
<p>正如通过<code>HttpServletRequest.getParameter()</code>方法检索的各个参数值一样，
从<code>HttpServletRequest.getQueryString()</code>获得的值应该被认为是不安全的。
在将查询字符串传递给敏感API之前，您可能需要验证或净化从查询字符串中提取的任何内容。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSQ">查询字符串</BugCode>


    <BugPattern type="SERVLET_HEADER">
        <ShortDescription>不受信任的HTTP标头</ShortDescription>
        <LongDescription>客户端可以轻易更改请求的HTTP头</LongDescription>
        <Details>
            <![CDATA[
<p>发出请求的用户可以轻易更改请求的HTTP头。通常，您不应该假设请求将来自常规浏览器而没有被攻击者更改。
 因此, 建议您在对请求做出的任何安全决策时不要信任此值。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSH">不受信任的HTTP标头</BugCode>


    <BugPattern type="SERVLET_HEADER_REFERER">
        <ShortDescription>不受信任的Referer标头</ShortDescription>
        <LongDescription>"Referer"标头很容易被客户端欺骗</LongDescription>
        <Details>
            <![CDATA[
<p>
Behavior:
<ul>
<li>如果请求来自恶意用户，该标头可以被赋予任意的值。</li>
<li>如果请求是从另一个安全的来源（https）发起的，则“Referer”将不存在。</li>
</ul>
</p>
<p>
建议:
<ul>
<li>访问控制不应该基于此标头的值。</li>
<li>CSRF保护不应该基于此值(<a href="http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14">因为它时可选的</a>)。</li>
</ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSHR">不受信任的Referer标头</BugCode>


    <BugPattern type="SERVLET_HEADER_USER_AGENT">
        <ShortDescription>不受信任的User-Agent标头</ShortDescription>
        <LongDescription>"User-Agent"标头很容易被客户端欺骗</LongDescription>
        <Details>
            <![CDATA[
<p>"User-Agent"标头很容易被客户端欺骗。建议不要基于User-Agent（针对爬虫UA）采取不同行为。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/807.html">CWE-807: Untrusted Inputs in a Security Decision</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSHUA">User-Agent标头</BugCode>


    <!-- Cookie usage -->
    <Detector class="com.h3xstream.findsecbugs.cookie.CookieReadDetector">
        <Details>识别直接使用cookie的情况</Details>
    </Detector>

    <BugPattern type="COOKIE_USAGE">
        <ShortDescription>cookie中的潜在敏感信息</ShortDescription>
        <LongDescription>应用程序可能会将敏感信息保存在cookie中</LongDescription>
        <Details>
            <![CDATA[
<p>存储在自定义cookie中的信息不应该是敏感的或与会话相关。 大多数情况下, 敏感数据只应被保存在会话中，并且通过用户的会话cookie引用。请参阅 HttpSession (HttpServletRequest.getSession())</p>
<p>自定义cookies用于需要比特定会话生命周期更长且独立于特定会话的信息。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/315.html">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCU">Cookie中的潜在敏感信息</BugCode>


    <!-- Path traversal -->
    <Detector class="com.h3xstream.findsecbugs.file.PathTraversalDetector">
        <Details>识别直接将路径作为参数的文件系统访问请求。</Details>
    </Detector>

    <BugPattern type="PATH_TRAVERSAL_IN">
        <ShortDescription>潜在的路径遍历 (文件读取)</ShortDescription>
        <LongDescription>方法{3}在用户指定的位置读取文件。</LongDescription>
        <Details>
            <![CDATA[
<p>打开文件以读取其内容，文件名来自<b>input</b> 参数。
如果将未过滤的参数传递给此文件API, 则可以读取来自任意文件系统位置的文件。</p>
<p>此规则识别<b>潜在的</b>路径遍历漏洞。在许多情况下, 用户无法控制构造的文件路径。在这种情况下，报告的案例是误报。</p>
<br/>

<p>
    <b>缺陷代码:</b><br/>
<pre>@GET
@Path("/images/{image}")
@Produces("images/*")
public Response getImage(@javax.ws.rs.PathParam("image") String image) {
    File file = new File("resources/images/", image); //Weak point

    if (!file.exists()) {
        return Response.status(Status.NOT_FOUND).build();
    }

    return Response.ok().entity(new FileInputStream(file)).build();
}</pre>
</p>
<br/>

<p>
    <b>解决方案:</b><br/>
<pre>import org.apache.commons.io.FilenameUtils;

@GET
@Path("/images/{image}")
@Produces("images/*")
public Response getImage(@javax.ws.rs.PathParam("image") String image) {
    File file = new File("resources/images/", FilenameUtils.getName(image)); //Fix

    if (!file.exists()) {
        return Response.status(Status.NOT_FOUND).build();
    }

    return Response.ok().entity(new FileInputStream(file)).build();
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPTI">潜在的路径遍历 (文件读取)</BugCode>


    <BugPattern type="PATH_TRAVERSAL_OUT">
        <ShortDescription>潜在的路径遍历 (文件写入)</ShortDescription>
        <LongDescription>方法{3} 在用户指定的位置写入文件。</LongDescription>
        <Details>
            <![CDATA[
<p>打开文件以写入其内容。文件名来自 <b>input</b> 参数。
如果将未过滤的参数传递给此文件API, 则可以更改来自文件系统任意位置的文件。</p>
<p>此规则识别<b>潜在的</b>路径遍历漏洞。在许多情况下, 用户无法控制构造的文件路径。在这种情况下，报告的案例是误报。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC-33: Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPTO">潜在的路径遍历 (文件写入)</BugCode>

    <!-- Path traversal with a Scala-specific code sample -->
    <BugPattern type="SCALA_PATH_TRAVERSAL_IN">
        <ShortDescription>潜在的路径遍历 (文件读取)</ShortDescription>
        <LongDescription>方法{3}在用户指定的位置读取文件。</LongDescription>
        <Details>
            <![CDATA[
<p>打开文件以读取其内容，文件名来自<b>input</b> 参数。
如果将未过滤的参数传递给此文件API, 则可以读取来自任意文件系统位置的文件。</p>
<p>此规则识别<b>潜在的</b>路径遍历漏洞。在许多情况下, 用户无法控制构造的文件路径。在这种情况下，报告的案例是误报。</p>
<br/>

<p>
    <b>缺陷代码:</b><br/>
<pre>def getWordList(value:String) = Action {
  if (!Files.exists(Paths.get("public/lists/" + value))) {
    NotFound("File not found")
  } else {
    val result = Source.fromFile("public/lists/" + value).getLines().mkString // Weak point
    Ok(result)
  }
}</pre>
</p>
<br/>

<p>
    <b>解决方案:</b><br/>
<pre>import org.apache.commons.io.FilenameUtils;

def getWordList(value:String) = Action {
  val filename = "public/lists/" + FilenameUtils.getName(value)

  if (!Files.exists(Paths.get(filename))) {
    NotFound("File not found")
  } else {
    val result = Source.fromFile(filename).getLines().mkString // Fix
    Ok(result)
  }
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SSECPTI">潜在的路径遍历 (文件读取)</BugCode>

    <!-- Command injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.command.CommandInjectionDetector">
        <Details>识别命令注入的来源</Details>
    </Detector>

    <BugPattern type="COMMAND_INJECTION">
        <ShortDescription>潜在的命令注入</ShortDescription>
        <LongDescription>使用方法{3} 可能容易受到命令注入攻击</LongDescription>
        <Details>
            <![CDATA[
<p>突出显示的API用于执行系统命令。如果将未过滤的输入传递给此API, 可能导致任意命令的执行。</p>
<br/>
<p>
    <b>缺陷代码:</b><br/>
<pre>import java.lang.Runtime;

Runtime r = Runtime.getRuntime();
r.exec("/bin/sh -c some_tool" + input);</pre>
</p>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Command_Injection">OWASP: Command Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/78.html">CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCI">命令注入</BugCode>


    <BugPattern type="SCALA_COMMAND_INJECTION">
        <ShortDescription>潜在的命令注入 (Scala)</ShortDescription>
        <LongDescription>命令执行可能容易受到注入</LongDescription>
        <Details>
            <![CDATA[
<p>突出显示的API用于执行系统命令。如果将未过滤的输入传递给此API, 可能导致任意命令的执行。</p>
<br/>
<p>
    <b>缺陷代码:</b><br/>
<pre>def executeCommand(value:String) = Action {
    val result = value.!
    Ok("Result:\n"+result)
}</pre>
</p>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Command_Injection">OWASP: Command Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/78.html">CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSCI">命令注入 (Scala)</BugCode>

    <!-- Weak FilenameUtils method -->
    <Detector class="com.h3xstream.findsecbugs.WeakFilenameUtilsMethodDetector">
        <Details>识别FilenameUtils的一些方法的使用情况</Details>
    </Detector>

    <BugPattern type="WEAK_FILENAMEUTILS">
        <ShortDescription>FilenameUtils 没有过滤空字节</ShortDescription>
        <LongDescription>FilenameUtils.{3} 没有过滤空字节</LongDescription>
        <Details>
            <![CDATA[
<p>某些FilenameUtils的方法不会过滤NULL字节(<code>0x00</code>).</p>
<p>如果将一个空字节注入文件名, 如果将此文件名传递给底层操作系统, 检索到的文件将是NULL字节之前指定的文件的名称。
因为在操作系统级别, 所有字符串都以一个空字节终止，即使Java本身不关心空字节或将它们视为特殊字节。
此操作系统行为可用于绕过文件名验证， 验证方法通过查看文件名的末尾(例如, 以 ".log"结尾) 来确保要访问的文件是安全的。</p>
<p>要解决这个问题, 建议做两件事:
<ul>
<li>将Java升级到7u40或更高的版本, 或Java 8+ 因为
<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8014846">这些版本修复了对文件名的NULL字节注入</a>.</li>
<li>强验证不受信任的用户提供的任何文件名，以确保它们有效（即，不包含null，不包括路径字符等）</li>
</ul>
<p>如果你知道你使用的Java版本对NULL字节注入免疫, 则可以禁用此规则</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246949/Null%20Byte%20Injection">WASC-28: Null Byte Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/158.html">CWE-158: Improper Neutralization of Null Byte or NUL Character</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWF">FilenameUtils没有过滤Null字节</BugCode>


    <!-- Weak TrustManager -->
    <Detector class="com.h3xstream.findsecbugs.crypto.WeakTrustManagerDetector">
        <Details>识别弱的TrustManager实现</Details>
    </Detector>

    <!-- SSL Disabler -->
    <Detector class="com.h3xstream.findsecbugs.scala.SslDisablerDetector">
        <Details>识别"SSL Disabler"实用工具类的使用</Details>
    </Detector>

    <BugPattern type="WEAK_TRUST_MANAGER">
        <ShortDescription>TrustManager未进行证书校验</ShortDescription>
        <LongDescription>TrustManager接受任意证书，易造成中间人攻击</LongDescription>
        <Details>
            <![CDATA[
<p>空的TrustManager实现通常用于轻松连接到未由根<a href="http://en.wikipedia.org/wiki/Certificate_authority">证书颁发机构</a>签名的主机。
 因此, 这很容易受到<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>，因为客户端会相信任何证书。
</p>
<p>
应该构建一个允许特定证书（例如基于信任库）的TrustManager。
关于正确实现的详细信息，请参阅:
<a href="http://stackoverflow.com/a/6378872/89769">[1]</a> 
<a href="http://stackoverflow.com/a/5493452/89769">[2]</a>
</p>
<br/>
<p>
    <b>缺陷代码:</b><br/>
<pre>class TrustAllManager implements X509TrustManager {

    @Override
    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
        //Trust any client connecting (no certificate validation)
    }

    @Override
    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
        //Trust any remote server (no certificate validation)
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
}</pre>
</p>
<br/>
<p>
    <b>解决方案 (基于keystore的TrustManager实现):</b><br/>
<pre>KeyStore ks = //Load keystore containing the certificates trusted

SSLContext sc = SSLContext.getInstance("TLS");

TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks);

sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/295.html">CWE-295: Improper Certificate Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWTM">弱的TrustManager实现</BugCode>

    <BugPattern type="WEAK_HOSTNAME_VERIFIER">
        <ShortDescription>HostnameVerifier域名(Hostname)校验不严格</ShortDescription>
        <LongDescription>HostnameVerifier接受任意签名的证书，易造成中间人攻击</LongDescription>
        <Details>
            <![CDATA[
<p>由于许多主机上的证书重用，通常会使用接受任何主机的<code> HostnameVerifier </ code>。
因此, 这很容易受到<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>，因为客户端会信任任何证书.
</p>
<p>
应该构建一个允许特定证书（例如基于信任库）的TrustManager。
应创建带通配符的证书以在多个子域上重复使用。
关于正确实现的详细信息，请参阅:
<a href="http://stackoverflow.com/a/6378872/89769">[1]</a>
<a href="http://stackoverflow.com/a/5493452/89769">[2]</a>
</p>
<br/>
<p>
    <b>缺陷代码:</b><br/>
<pre>public class AllHosts implements HostnameVerifier {
    public boolean verify(final String hostname, final SSLSession session) {
        return true;
    }
}</pre>
</p>
<br/>
<p>
    <b>解决方案(基于keystore的TrustManager实现):</b><br/>
<pre>KeyStore ks = //Load keystore containing the certificates trusted

SSLContext sc = SSLContext.getInstance("TLS");

TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks);

sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/295.html">CWE-295: Improper Certificate Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWHV">弱的TrustManager实现</BugCode>



    <!-- JAXWS -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.JaxWsEndpointDetector">
        <Details>识别实现JAX-WS API的Web服务端点</Details>
    </Detector>

    <BugPattern type="JAXWS_ENDPOINT">
        <ShortDescription>找到JAX-WS SOAP端点</ShortDescription>
        <LongDescription>{0}.{1}是一个SOAP网络服务端点</LongDescription>
        <Details>
            <![CDATA[
<p>此方法是SOAP网络服务的一部分(JSR224)。</p>
<p>
<b>应该分析网络服务的安全性。 例如:</b>
<ul>
<li>应该测试它是否强制身份认证。</li>
<li>应该测试它是否强制访问控制。</li>
<li>应该跟踪输入以查找潜在的漏洞。</li>
<li>理想情况下，通信应该通过SSL。</li>
</ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet">OWASP: Web Service Security Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJWS">JAX-WS SOAP端点</BugCode>


    <!-- JAXRS -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.JaxRsEndpointDetector">
        <Details>识别实现JAX-RS API的网络服务端点</Details>
    </Detector>

    <BugPattern type="JAXRS_ENDPOINT">
        <ShortDescription>找到JAX-RS REST端点</ShortDescription>
        <LongDescription>{0}.{1} 是一个REST 网络服务端点</LongDescription>
        <Details>
            <![CDATA[
<p>此方法是REST网络服务的一部分(JSR311)。</p>
<p>
<b>应该分析网络服务的安全性。 例如:</b>
<ul>
<li>应该测试它是否强制身份认证。</li>
<li>应该测试它是否强制访问控制。</li>
<li>应该跟踪输入以查找潜在的漏洞。</li>
<li>理想情况下，通信应该通过SSL。</li>
<li>如果服务支持写入(例如, 通过POST), 我们需要调查CSRF漏洞。<sup>[1]</sup></li>
</ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet">OWASP: REST Assessment Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet">OWASP: REST Security Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet">OWASP: Web Service Security Cheat Sheet</a><br/>
1. <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">OWASP: Cross-Site Request Forgery</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJRS">JAX-RS REST端点</BugCode>


    <!-- Tapestry -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.TapestryEndpointDetector">
        <Details>识别Tapestry“Pages”以接受用户输入</Details>
    </Detector>

    <BugPattern type="TAPESTRY_ENDPOINT">
        <ShortDescription>找到Tapestry页面</ShortDescription>
        <LongDescription>{0}是一个Tapestry页面</LongDescription>
        <Details>
            <![CDATA[
<p>在应用程序启动时发现了Tapestry端点。Tapestry应用程序由每个页面的Java支持类和相应的Tapestry标记语言页面（.tml文件）构成。
 收到请求时，GET / POST参数将映射到Java支持类中的特定输入。 映射要么使用字段名来完成:</p>
<pre><code>
    [...]
    protected String input;
    [...]
</code></pre>
<p>要么使用显式注释的定义来完成:
</p>
<pre><code>
    [...]
    @org.apache.tapestry5.annotations.Parameter
    protected String parameter1;

    @org.apache.tapestry5.annotations.Component(id = "password")
    private PasswordField passwordField;
    [...]
</code></pre>
<p>该页面映射到视图<code>[/resources/package/PageName].tml.</code></p>
<p>应该研究此应用程序中的每个Tapestry页面，以确保通过这种方式自动映射的所有输入在使用之前都已正确验证。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://tapestry.apache.org/">Apache Tapestry Home Page</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECTE">Tapestry页面</BugCode>

    <!-- Wicket -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.WicketEndpointDetector">
        <Details>识别作为输入的Wicket "WebPages"</Details>
    </Detector>

    <BugPattern type="WICKET_ENDPOINT">
        <ShortDescription>找到Wicket网页</ShortDescription>
        <LongDescription>{0}是一个Wicket网页</LongDescription>
        <Details>
            <![CDATA[
<p>此类代表Wicket的WebPage。 输入是从传递给构造函数的PageParameters实例自动读取的。
当前页面映射到视图[/package/WebPageName].html。</p>
<p>应该研究此应用程序的每个Wicket页面，以确保通过这种方式自动映射的所有输入在使用之前都已正确验证。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://wicket.apache.org/">Apache Wicket Home Page</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWE">Wicket页面</BugCode>


    <!-- Weak Message Digest MD5 and SHA1 -->
    <Detector class="com.h3xstream.findsecbugs.crypto.WeakMessageDigestDetector">
        <Details>识别可替换的弱信息摘要算法的使用。</Details>
    </Detector>

    <BugPattern type="WEAK_MESSAGE_DIGEST_MD5">
        <ShortDescription>MD2, MD4 and MD5弱信息摘要算法使用</ShortDescription>
        <LongDescription>{3}不是理想信息摘要算法</LongDescription>
        <Details>
            <![CDATA[
<p>MD2, MD4 和 MD5不是理想信息摘要算法。 例如<b>PBKDF2</b> 可用于哈希密码。</p>

<blockquote>
    "MD5哈希函数的安全性不足。 存在碰撞攻击，该攻击可以几秒钟内在具有2.6 GHz Pentium 4处理器的计算机上发现冲突 (复杂度为2<sup>24.1</sup>)。
    [1] 此外, 还存在一种选择前缀碰撞攻击，它可以使用现成的计算硬件在几个小时内产生具有指定前缀的两个输入的冲突。[2]"<br/>
    - <a href="https://en.wikipedia.org/wiki/MD5#Security">Wikipedia: MD5 - Security</a>
</blockquote>

<blockquote>
    "<b>SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, 以及 SHA-512/256</b>:<br/>
    所有应用程序都可以使用这些哈希函数。"<br/>
    - <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<blockquote>
    "PBKDF的主要思想是通过增加测试每个密码所需的时间来减慢字典攻击或暴力破解。具有可能密码列表的攻击者可以使用已知的迭代计数器和salt值来评估PBKDF。
     由于攻击者每次尝试都需要花费大量的计算时间，因此使用字典攻击或暴力破解会变得更加困难。"<br/>
- <a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf">NIST: Recommendation for Password-Based Key Derivation  p.12</a>
</blockquote>
<br/>
<p>
    <b>缺陷代码:</b><br/>
    <pre>MessageDigest md5Digest = MessageDigest.getInstance("MD5");
    md5Digest.update(password.getBytes());
    byte[] hashValue = md5Digest.digest();</pre>
    <br/>
    <pre>byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());</pre>
</p>
<br/>
<p>
    <b>解决方案 (利用开源的轻量级密码术包Bouncy Castle):</b><br/>
    <pre>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());
    gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);
    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();
}</pre>
    <br/>
    <b>解决方案 (Java 8 或更高版本):</b><br/>
    <pre>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);
    SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    return f.generateSecret(spec).getEncoded();
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
[1] <a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf">On Collisions for MD5</a>: Master Thesis by M.M.J. Stevens<br/>
[2] <a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf">Chosen-prefix collisions for MD5 and applications</a>: Paper written by Marc Stevens<br/>
<a href="https://en.wikipedia.org/wiki/MD5">Wikipedia: MD5</a><br/>
<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br/>
<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf">NIST: Recommendation for Password-Based Key Derivation</a><br/>
<a href="http://stackoverflow.com/questions/22580853/reliable-implementation-of-pbkdf2-hmac-sha256-for-java">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br/>
<a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECMD5">MD2, MD4 and MD5弱信息摘要算法使用</BugCode>


    <BugPattern type="WEAK_MESSAGE_DIGEST_SHA1">
        <ShortDescription>SHA-1弱信息摘要算法</ShortDescription>
        <LongDescription>{3}不是理想的信息摘要算法</LongDescription>
        <Details>
            <![CDATA[
<p>SHA-1算法对于哈希密码, 签名验证和其他用途来说不是理想的算法。 例如<b>PBKDF2</b> 可用于哈希密码。</p>

<blockquote>
    "<b>SHA-1用于生成数字签名:</b><br/>
    SHA-1只有在符合NIST特定协议指南规定的情况下才能用于生成数字签名。
    对于所有其他应用程序, <u>SHA-1不应用于生成数字签名</u>。<br/>
    <b>SHA-1用于数字签名验证:</b><br/>
    对于数字签名验证, <u>允许继续使用SHA-1</u>。<br/>
    [...]<br/>
    <b>SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, 以及 SHA-512/256</b>:<br/>
    所有应用程序都可以使用这些哈希函数。"<br/>
    - <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<blockquote>
    "PBKDF的主要思想是通过增加测试每个密码所需的时间来减慢字典攻击或暴力破解。具有可能密码列表的攻击者可以使用已知的迭代计数器和salt值来评估PBKDF。
     由于攻击者每次尝试都需要花费大量的计算时间，因此使用字典攻击或暴力破解会变得更加困难。"<br/>
- <a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf">NIST: Recommendation for Password-Based Key Derivation  p.12</a>

</blockquote>
<br/>
<p>
    <b>缺陷代码:</b><br/>
    <pre>MessageDigest sha1Digest = MessageDigest.getInstance("SHA1");
    sha1Digest.update(password.getBytes());
    byte[] hashValue = sha1Digest.digest();</pre>
    <br/>
    <pre>byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());</pre>
</p>
<br/>
<p>
    <b>解决方案 (利用开源的轻量级密码术包Bouncy Castle):</b><br/>
    <pre>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());
    gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);
    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();
}</pre>
    <br/>
    <b>解决方案 (Java 8 或更高版本):</b><br/>
    <pre>public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);
    SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    return f.generateSecret(spec).getEncoded();
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know">Qualys blog: SHA1 Deprecation: What You Need to Know</a><br/>
<a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html">Google Online Security Blog: Gradually sunsetting SHA-1</a><br/>
<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br/>
<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf">NIST: Recommendation for Password-Based Key Derivation</a><br/>
<a href="http://stackoverflow.com/questions/22580853/reliable-implementation-of-pbkdf2-hmac-sha256-for-java">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br/>
<a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSHA1">SHA-1 弱信息摘要算法</BugCode>


    <!-- Weak SSL/TLS protocols -->
    <Detector class="com.h3xstream.findsecbugs.crypto.WeakTLSDetector">
        <Details>识别弱SSL/TLS协议的使用</Details>
    </Detector>

    <BugPattern type="DEFAULT_HTTP_CLIENT">
        <ShortDescription>默认构造函数的DefaultHttpClient与TLS 1.2不兼容</ShortDescription>
        <LongDescription>默认构造函数的DefaultHttpClient与TLS 1.2不兼容</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>缺陷代码:</b><br/>
<pre>
    HttpClient client = new DefaultHttpClient();
</pre>
</p>
<p>
<p><b>解决方案:</b><br/>

使用推荐的构造函数之一来实现DefaultHttpClient，并配置https.protocols的JVM选项以包含TLSv1.2:</p>

<p>
<ul>
  <li>使用 <a href="http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/SystemDefaultHttpClient.html">SystemDefaultHttpClient</a> 进行替换</li>
<p>
    <b>示例代码:</b><br/>
<pre>
    HttpClient client = new SystemDefaultHttpClient();
</pre>
</p>
  <li>基于SSLSocketFactory创建一个HttpClient - 使用<a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()">getSystemSocketFactory()</a> 来获取SSLScoketFactory实例并利用这个实例来创建HttpClient。</li>
  <li>基于SSLConnectionSocketFactory创建一个HttpClient - 使用<a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLConnectionSocketFactory.html#getSystemSocketFactory()">getSystemSocketFactory()</a> 获取一个SSLConnectionSocketFactory实例并利用这个实例来创建HttpClient。</li>
  <li>使用HttpClientBuilder - 调用build()前先调用 <a href="http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/HttpClientBuilder.html#useSystemProperties()">useSystemProperties()</a></li>
<p>
    <b>示例代码:</b><br/>
<pre>
    HttpClient client = HttpClientBuilder.create().useSystemProperties().build();
</pre>
</p>
  <li>使用HttpClients - 调用<a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/HttpClients.html#createSystem()">createSystem()</a> 来创建一个HttpClient实例。</li>
<p>
    <b>示例代码:</b><br/>
<pre>
    HttpClient client = HttpClients.createSystem();
</pre>
</p>
</ul>
</p>
<br/>

<p>
<b>参考资料</b><br/>
<a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https">Diagnosing TLS, SSL, and HTTPS</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHTTPCLIENT">DefaultHttpClient</BugCode>

    <BugPattern type="SSL_CONTEXT">
        <ShortDescription>弱SSLContext</ShortDescription>
        <LongDescription>SSLContext需要与TLS 1.2兼容</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>缺陷代码:</b><br/>
<pre>
    SSLContext.getInstance("SSL");
</pre>
</p>
<p>
<p><b>解决方案:</b><br/>

使用以下构造方法, 并配置https.protocols的JVM选项以包含TLSv1.2:</p>
<pre>
    SSLContext.getInstance("TLS");
</pre>
<p>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https">Diagnosing TLS, SSL, and HTTPS</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSL">SSLContext</BugCode>

    <!-- Custom Message Digest -->
    <Detector class="com.h3xstream.findsecbugs.crypto.CustomMessageDigestDetector">
        <Details>识别自定义信息摘要 / 哈希算法的实现</Details>
    </Detector>

    <BugPattern type="CUSTOM_MESSAGE_DIGEST">
        <ShortDescription>自定义信息摘要算法</ShortDescription>
        <LongDescription>{0}是自定义加密哈希函数的实现</LongDescription>
        <Details>
            <![CDATA[
<p>实现自定义MessageDigest很容易出错。</p>
<p><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">NIST</a> recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or SHA-512/256.</p>
<blockquote>
    "<b>SHA-1用于生成数字签名:</b><br/>
    SHA-1只有在符合NIST特定协议指南规定的情况下才能用于生成数字签名。
    对于所有其他应用程序, <u>SHA-1不应用于生成数字签名</u>。<br/>
    <b>SHA-1用于数字签名验证:</b><br/>
    对于数字签名验证, <u>允许继续使用SHA-1</u>。<br/>
    [...]<br/>
    <b>SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, 以及 SHA-512/256</b>:<br/>
    所有应用程序都可以使用这些哈希函数。"<br/>
    - <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15</a>
</blockquote>
<p>
    <b>缺陷代码:</b><br/>
<pre>MyProprietaryMessageDigest extends MessageDigest {
    @Override
    protected byte[] engineDigest() {
        [...]
        //自定义摘要算法
        return [...];
    }
}</pre>
</p>
<p>
<p>使用SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256进行信息摘要的计算。使用足够强大的算法来满足您的特定安全需求。</p>
<p>
    <b>示例代码:</b><br/>
<pre>MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
sha256Digest.update(password.getBytes());</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html">NIST Approved Hashing Algorithms</a><br/>
<a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCMD">自定义信息摘要算法</BugCode>


    <!-- FileUpload Filename -->
    <Detector class="com.h3xstream.findsecbugs.file.FileUploadFilenameDetector">
        <Details>FileUpload API给出的文件名可能被客户端篡改。</Details>
    </Detector>

    <BugPattern type="FILE_UPLOAD_FILENAME">
        <ShortDescription>读取被污染的文件名</ShortDescription>
        <LongDescription>读取的文件名可能被客户端篡改</LongDescription>
        <Details>
            <![CDATA[
<p>客户端可以篡改FileUpload API提供的文件名以引用未经授权的文件。</p>
<p>例如:</p>
<ul>
<li><code>"../../../config/overide_file"</code></li>
<li><code>"shell.jsp\u0000expected.gif"</code></li>
</ul>
<p>因此, 不应将此类值直接传递给文件系统API。 如果可能，应用程序应生成并使用自己的文件名。
 否则，应正确验证提供的文件名，以确保其结构正确，不包含未经授权的路径字符（例如，/ \），并引用授权文件。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://blogs.securiteam.com/index.php/archives/1268">Securiteam: File upload security recommendations</a><br/>
<a href="http://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a><br/>
<a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC-33: Path Traversal</a><br/>
<a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
<a href="http://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a><br/>
<a href="http://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECFUN">读取被污染的文件名</BugCode>


    <!-- ReDOS -->
    <Detector class="com.h3xstream.findsecbugs.ReDosDetector">
        <Details>正则表达式的处理时间随着某些输入呈指数增长。</Details>
    </Detector>

    <BugPattern type="REDOS">
        <ShortDescription>针对正则表达式的DOS攻击 (ReDOS)</ShortDescription>
        <LongDescription>正则表达式 "{0}" 容易遭受拒绝服务攻击 (ReDOS)</LongDescription>
        <Details>
            <![CDATA[
<p>
    正则表达式(regexs)经常遭到拒绝服务(DOS)攻击(叫做 ReDOS). 这是因为在分析某些字符串时，正则表达式引擎可能会花费大量时间，具体取决于正则表达式的定义方式。
<p>
    例如, 对于正则表达式: <b>^(a+)+$</b>, 输入"<code>aaaaaaaaaaaaaaaaX</code>" 将导致正则表达式引擎分析65536个不同的路径。
    <sup>[1] 摘自OWASP参考文献</sup></p>
<p>
因此, 单个请求可能会导致服务器端的大量计算。
这个正则表达式和其他类似的正则表达式的问题在于，由于括号内和括号外都有+（或a *），正则表达式对于相同的输入字符有两种分析方式。对于这样的表达式, 两个 + 号都可以消耗字符 'a'。
 要解决这个问题，应该重写正则表达式以消除歧义。 例如, 这个表达式可以简单的重写成: <b>^a+$</b>, 这大概就是作者的意思（任何数量的a）。
 假设这是原始正则表达式的含义，这个新的正则表达式可以被快速评估，并免于ReDOS攻击。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://www.jroller.com/sebastianKuebeck/entry/detecting_and_preventing_redos_vulnerabilities">Sebastian Kubeck's Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br/>
<sup>[1]</sup> <a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS">OWASP: Regular expression Denial of Service</a><br/>
<a href="http://cwe.mitre.org/data/definitions/400.html">CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRD">针对正则表达式的DOS攻击</BugCode>

    <!-- XMLStreamReader XXE -->
    <Detector class="com.h3xstream.findsecbugs.xml.XmlStreamReaderDetector">
        <Details>识别容易受到XXE影响的XMLStreamReader使用</Details>
    </Detector>

    <BugPattern type="XXE_XMLSTREAMREADER">
        <ShortDescription>XML解析容易受到XXE攻击 (XMLStreamReader)</ShortDescription>
        <LongDescription>XML解析容易遭到XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接受的XML时，可能遭受XML外部实体 (XXE) 攻击。</p>
<p><b>风险 1: 暴露本地文件内容 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险 2: 拒绝服务 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>禁用外部实体的解决方案:</b></p>
<p>
<pre>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
<pre>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a href="http://openjdk.java.net/jeps/185">JEP 185: Restrict Fetching of External XML Resources</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXESTR">使用XMLStreamReader容易受到XXE攻击</BugCode>

    <!-- SAXParser XXE -->
    <Detector class="com.h3xstream.findsecbugs.xml.XxeDetector">
        <Details>识别容易受到XXE攻击的XML解析器</Details>
    </Detector>

	<BugPattern type="XXE_XPATH">
        <ShortDescription>XML解析易受XXE攻击（XPathExpression）</ShortDescription>
        <LongDescription>使用{3}容易受到XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接收的XML时，可能会发生XML外部实体（XXE）攻击。</p>
<p><b>风险1：公开本地文件内容(XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险2：拒绝服务(XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>DocumentBuilder builder = df.newDocumentBuilder();

XPathFactory xPathFactory = XPathFactory.newInstance();
XPath xpath = xPathFactory.newXPath();
XPathExpression xPathExpr = xpath.compile("/somepath/text()");

xPathExpr.evaluate(new InputSource(inputStream));</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
此设置将保护您免受拒绝服务攻击和远程文件访问。
<pre>
DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
df.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</pre>
</p>
<br/>
<p>
<b>参考方案</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XPathExpression">XML External Entity (XXE) Prevention Cheat Sheet</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXEXPA">XML解析易受XXE攻击</BugCode>

    <BugPattern type="XXE_SAXPARSER">
        <ShortDescription>XML解析容易受到XXE攻击(SAXParser)</ShortDescription>
        <LongDescription>{3}的使用容易遭到 XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接受的XML时，可能遭受XML外部实体 (XXE) 攻击。</p>
<p><b>风险 1: 暴露本地文件内容 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险 2: 拒绝服务 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>
SAXParser parser = SAXParserFactory.newInstance().newSAXParser();

parser.parse(inputStream, customHandler);</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
此设置将保护您免受拒绝服务攻击和远程文件访问。
<pre>
SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a href="http://xerces.apache.org/xerces-j/features.html">Xerces complete features list</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXESAX">使用SAXParser容易受到XXE攻击</BugCode>

    <BugPattern type="XXE_XMLREADER">
        <ShortDescription>XML解析容易受到XXE攻击 (XMLReader)</ShortDescription>
        <LongDescription>{3}的使用容易遭受XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接受的XML时，可能遭受XML外部实体 (XXE) 攻击。</p>
<p><b>风险 1: 暴露本地文件内容 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险 2: 拒绝服务 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>
XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setContentHandler(customHandler);
reader.parse(new InputSource(inputStream));</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
此设置将保护您免受拒绝服务攻击和远程文件访问。
<pre>
XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a href="http://xerces.apache.org/xerces-j/features.html">Xerces complete features list</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXEREAD">使用XMLReader容易受到XXE攻击</BugCode>

    <BugPattern type="XXE_DOCUMENT">
        <ShortDescription>XML解析容易受到XXE攻击 (DocumentBuilder)</ShortDescription>
        <LongDescription>{3}的使用容易受到XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接受的XML时，可能遭受XML外部实体 (XXE) 攻击。</p>
<p><b>风险 1: 暴露本地文件内容 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险 2: 拒绝服务 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>
DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();

Document doc = db.parse(input);</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
This setting will protect you against Denial of Service attack and remote file access.
<pre>
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
<a href="http://xerces.apache.org/xerces2-j/features.html">Xerces2 complete features list</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXEDOC">使用DocumentBuilder容易受到XXE攻击</BugCode>

    <!-- XPath Injection for Javax -->
	    <Detector class="com.h3xstream.findsecbugs.xml.TransformerFactoryDetector">
        <Details>使用TransformerFactory XML解析器容易遭到XXE攻击</Details>
    </Detector>

    <BugPattern type="XXE_DTD_TRANSFORM_FACTORY">
        <ShortDescription>XML解析易受XXE攻击(TransformerFactory)</ShortDescription>
        <LongDescription>使用{3}容易受到XML外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持XML实体的XML解析器在处理从不受信任的源接受的XML时，可能遭受XML外部实体 (XXE) 攻击。</p>
<p><b>风险 1: 暴露本地文件内容 (XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</pre>
</p>
<b>风险 2: 拒绝服务 (XEE: <u>X</u>ml <u>E</u>ntity <u>E</u>xpansion)</b>
<p>
<pre>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol &quot;lol&quot;&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
 &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;
 &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
[...]
 &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>
Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
This setting will protect you against remote file access but not denial of service.
<pre>
TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXETFDTD">使用TransformerFactory容易遭到XXE攻击</BugCode>

    <BugPattern type="XXE_XSLT_TRANSFORM_FACTORY">
        <ShortDescription>XSLT解析易受XXE攻击(TransformerFactory)</ShortDescription>
        <LongDescription>使用{3}容易受到XSLT外部实体攻击</LongDescription>
        <Details>
            <![CDATA[
<!--XXE_GENERIC_START-->
<h3>攻击</h3>
<p>当支持外部实体的XSLT解析器在处理从不受信任的源接收的XSLT时，可能会发生XSLT外部实体（XXE）攻击。</p>
<p><b>风险：公开本地文件内容(XXE: <u>X</u>ML e<u>X</u>ternal <u>E</u>ntity)</b></p>
<p>
<pre>
&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;
   &lt;xsl:template match=&quot;/&quot;&gt;
       &lt;xsl:value-of select=&quot;document(&apos;/etc/passwd&apos;)&quot;&gt;
   &lt;/xsl:value-of&gt;&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
</p>

<h3>解决方案</h3>
<p>
为了避免暴露XML解析器的危险特性，您可以对代码进行以下更改。
</p>
<!--XXE_GENERIC_END-->

<p><b>缺陷代码:</b></p>
<p>
<pre>
Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</pre>
</p>
<br/>
<p>
以下代码段显示了两种可用的解决方案。您可以选择其中一个或两个。
</p>

<p><b>使用"安全处理"模式的解决方案:</b></p>
<p>
This setting will protect you against remote file access but not denial of service.
<pre>
TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</pre>
</p>

<p><b>禁用DTD的解决方案:</b></p>
<p>
通过禁用DTD, 基本上所有的XXE攻击都可以被阻止。
<pre>
TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<!--XXE_GENERIC_START-->
<a href="http://cwe.mitre.org/data/definitions/611.html">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<!--XXE_GENERIC_END-->
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXXETFXSLT">在TransformerFactory中使用XSLT容易遭到XXE攻击</BugCode>

    <!-- XPath Injection for Javax -->
    <Detector class="com.h3xstream.findsecbugs.xpath.XPathInjectionDetector">
        <Details>查找使用受污染的输入的XPath查询</Details>
    </Detector>
    
    <BugPattern type="XPATH_INJECTION">
        <ShortDescription>潜在的XPath注入</ShortDescription>
        <LongDescription>{3}的使用容易受到XPath注入攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
XPath注入风险和SQL注入类似。 如果XPath查询包含不受信任的用户输入，可能会暴露完整的数据源。
这可能允许攻击者访问未经授权的数据或恶意修改目标XML。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-39: XPath Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/643.html">CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61407250">CERT: IDS09-J. Prevent XPath Injection (archive)</a><br/>
<a href="http://media.blackhat.com/bh-eu-12/Siddharth/bh-eu-12-Siddharth-Xpath-WP.pdf">Black Hat Europe 2012: Hacking XPath 2.0</a><br/>
<a href="http://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html">Balisage: XQuery Injection</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXPI">XPath注入</BugCode>

    <!-- Struts1 -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.Struts1EndpointDetector">
        <Details>识别Struts 1 端点(也叫Action)</Details>
    </Detector>

    <BugPattern type="STRUTS1_ENDPOINT">
        <ShortDescription>查找Struts 1 端点</ShortDescription>
        <LongDescription>{0} 是个Struts 1 端点 (Action)</LongDescription>
        <Details>
            <![CDATA[
<p>这个类是一个 Struts 1 Action.</p>
<p>将请求路由到此控制器后，将自动实例化包含HTTP参数的Form对象。
应审查这些参数的使用，以确保它们得到安全使用。</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSTR1">Struts 1 Action</BugCode>

    <!-- Struts2 -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.Struts2EndpointDetector">
        <Details>识别Struts 2 端点</Details>
    </Detector>
    <BugPattern type="STRUTS2_ENDPOINT">
        <ShortDescription>查找Struts 2 端点</ShortDescription>
        <LongDescription>{0} 是一个Struts 2 端点</LongDescription>
        <Details>
            <![CDATA[
<p>在Struts 2中，端点是简单Java对象（POJO），这意味着不需要实现接口/扩展类。</p>
<p>当请求被路由到其控制器（如所选类）时，提供的HTTP参数将自动映射到该类的setter函数。 因此，即使表单不包含这些值，也应将此类的所有setter视为不可信输入。
攻击者只需简单地在请求中提供额外的值，这些值无论如何都将被设置到对象中，只要该对象具有这样的setter函数。 应审查这些参数的使用，以确保它们得到安全使用。</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSTR2">Struts 2 端点</BugCode>


    <!-- Spring Controller -->
    <Detector class="com.h3xstream.findsecbugs.endpoint.SpringMvcEndpointDetector">
        <Details>识别Spring 端点 (也叫Controller)</Details>
    </Detector>
    <BugPattern type="SPRING_ENDPOINT">
        <ShortDescription>查找Spring端点</ShortDescription>
        <LongDescription>{0}是一个Spring端点 (Controller)</LongDescription>
        <Details>
            <![CDATA[
<p>这个类是一个 Spring Controller。 所有使用 <code>RequestMapping</code> 注释的方法(以及他的快捷注释 <code>GetMapping</code>, <code>PostMapping</code>, <code>PutMapping</code>, <code>DeleteMapping</code>, 以及 <code>PatchMapping</code>) 都可以远程访问。
应对此类进行分析，以确保远程公开的方法暴露给潜在的攻击者是安全的。</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSC">Spring 端点</BugCode>


    <!-- Spring CSRF Protection Disabled -->
    <Detector class="com.h3xstream.findsecbugs.csrf.SpringCsrfProtectionDisabledDetector">
        <Details>检测Spring CSRF保护的禁用</Details>
    </Detector>

    <BugPattern type="SPRING_CSRF_PROTECTION_DISABLED">
        <ShortDescription>Spring CSRF保护被禁用</ShortDescription>
        <LongDescription>对于标准的Web应用程序来说，禁用Spring Security 的CSRF 保护是不安全的</LongDescription>
        <Details>
            <![CDATA[
<p>对于标准的Web应用程序来说，禁用Spring Security 的CSRF 保护是不安全的。</p>
<p>禁用此保护的一个有效用例是服务公开状态改变操作，该操作保证仅由非浏览器客户端使用。</p>
<p>
    <b>不安全的配置:</b><br/>
<pre>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
    }
}</pre>
</p>
<p>
<b>参考资料</b><br/>
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection">Spring Security Official Documentation: When to use CSRF protection</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">OWASP: Cross-Site Request Forgery</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352: Cross-Site Request Forgery (CSRF)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSPRCSRFPD">Spring CSRF保护被禁用</BugCode>


    <!-- Spring CSRF Unrestricted RequestMapping -->
    <Detector class="com.h3xstream.findsecbugs.csrf.SpringCsrfUnrestrictedRequestMappingDetector">
        <Details>识别Spring CSRF不受限制的RequestMapping</Details>
    </Detector>

    <BugPattern type="SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING">
        <ShortDescription>Spring CSRF不受限制的RequestMapping</ShortDescription>
        <LongDescription>Spring不受限制的RequestMapping使该方法容易遭受CSRF攻击</LongDescription>
        <Details>
            <![CDATA[
<p>默认情况下，使用<code> RequestMapping </code>注释的方法将映射到所有HTTP请求方法。
但是，默认情况下，对于HTTP请求方法<code> GET </code>，<code> HEAD </code>，<code> TRACE </code>和<code> OPTIONS </code>，不启用Spring Security的CSRF保护（因为这可能导致令牌被泄露）。
因此, 会导致状态改变的方法使用 <code>RequestMapping</code> 注释，而不是将映射范围缩小到HTTP请求方法<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, 或 <code>PATCH</code>
将容易受到CSRF攻击。</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>@Controller
public class UnsafeController {

    @RequestMapping("/path")
    public void writeData() {
        // 这个方法里有改变状态的操作。
    }
}</pre>
</p>
<p>
    <b>解决方案 (Spring Framework 4.3 或更高版本):</b><br/>
<pre>@Controller
public class SafeController {

    /**
     * 没有副作用的方法使用 @GetMapping.
     */
    @GetMapping("/path")
    public String readData() {
        // 在此方法中不执行状态更改操作。
        return "";
    }

    /**
     * 导致状态改变的方法使用 @PostMapping, @PutMapping, @DeleteMapping, 或 @PatchMapping.
     */
    @PostMapping("/path")
    public void writeData() {
        // 在该方法中执行状态改变操作。
    }
}</pre>
</p>
<p>
    <b>解决方案 (Spring Framework 4.3 以前的版本):</b><br/>
<pre>@Controller
public class SafeController {

    /**
     * 没有状态改变的方法使用
     * RequestMethod.GET, RequestMethod.HEAD, RequestMethod.TRACE, 或 RequestMethod.OPTIONS.
     */
    @RequestMapping(value = "/path", method = RequestMethod.GET)
    public String readData() {
        // 在此方法中不执行状态更改操作。
        return "";
    }

    /**
     * 有状态改变的方法使用
     * RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE, 或 RequestMethod.PATCH.
     */
    @RequestMapping(value = "/path", method = RequestMethod.POST)
    public void writeData() {
        // 在该方法中执行状态改变操作。
    }
}</pre>
</p>
<p>
<b>参考资料</b><br/>
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#csrf-use-proper-verbs">Spring Security Official Documentation: Use proper HTTP verbs (CSRF protection)</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">OWASP: Cross-Site Request Forgery</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352: Cross-Site Request Forgery (CSRF)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSPRCSRFURM">Spring CSRF不受限制的RequestMapping</BugCode>


    <!-- Custom Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.custom.CustomInjectionDetector">
        <Details>为自定义方法检测注入的检测器。</Details>
    </Detector>

    <BugPattern type="CUSTOM_INJECTION">
        <ShortDescription>潜在的注入 (自定义方法)</ShortDescription>
        <LongDescription>{3} 的使用容易受到注入攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
识别出的方法容易受到注入攻击。应验证输入并正确转义。
</p>

<p>
    <b>缺陷代码实例:</b><br/>
    <pre>SqlUtil.execQuery("select * from UserEntity t where id = " + parameterInput);</pre>
</p>
<p>
    有关<a href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/Custom-signatures">如何配置自定义签名</a>的详细说明，请参阅在线Wiki。
</p>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCUSTOMI"> 自定义方法注入 </BugCode>


    <!-- SQL Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.sql.SqlInjectionDetector">
        <Details>识别接受字符串的SQL APIs(Hibernate, JPA and JDO) 中的各种SQL注入。</Details>
    </Detector>

    <!-- SQL Injection (Generic) -->
    <!-- Specialized description are below -->
    <BugPattern type="SQL_INJECTION">
        <ShortDescription>潜在的SQL注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
除了使用预编译语句, 也可以手动转义每个参数。
</p>
<p>
    <b>缺陷代码:</b><br/>
    <pre>
createQuery("select * from User where id = '"+inputId+"'");
</pre>
</p>
<p>
    <b>解决方案:</b><br/>

    <pre>
import org.owasp.esapi.Encoder;

createQuery("select * from User where id = '"+Encoder.encodeForSQL(inputId)+"'");
</pre>
</p>
<br/>
<p>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLI">SQL 注入</BugCode>

    <!-- SQL Injection Turbine -->
    <BugPattern type="SQL_INJECTION_TURBINE">
        <ShortDescription>Turbine的潜在SQL注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
Turbine API 提供一个 DSL 来使用Java代码创建查询语句。
</p>
<p>
    <b>缺陷代码:</b><br/>
    <pre>
List&lt;Record&gt; BasePeer.executeQuery( "select * from Customer where id=" + inputId );
</pre>
</p>
<p>
    <b>解决方案 (使用Criteria DSL):</b><br/>

    <pre>
Criteria c = new Criteria();
c.add( CustomerPeer.ID, inputId );

List&lt;Customer&gt; customers = CustomerPeer.doSelect( c );
</pre>

    <b>解决方案 (采用专门的方法):</b><br/>

<pre>
Customer customer = CustomerPeer.retrieveByPK( new NumberKey( inputId ) );
</pre>

    <b>解决方案 (使用OWASP Encoder):</b><br/>

    <pre>
import org.owasp.esapi.Encoder;

BasePeer.executeQuery("select * from Customer where id = '"+Encoder.encodeForSQL(inputId)+"'");
</pre>
</p>
<br/>
<p>
<b>参考资料 (Turbine)</b><br/>
<a href="https://turbine.apache.org/turbine/turbine-2.1/howto/criteria-howto.html">Turbine Documentation: Criteria Howto</a><br/>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLITU">Turbine的潜在SQL注入</BugCode>

    <!-- HQL Injection -->
    <BugPattern type="SQL_INJECTION_HIBERNATE">
        <ShortDescription>潜在的SQL/HQL注入 (Hibernate)</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL/HQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
处了预编译语句, 还可以使用Hibernate Criteria。
</p>
<p>
    <b>缺陷代码:</b><br/>
    <pre>
Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = " + input);
q.execute();</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>
Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = :userId");
q.setString("userId",input);
q.execute();</pre>
</p>
<p>
    <b>动态查询的解决方案 (使用Hibernate Criteria):</b><br/>
    <pre>
Session session = sessionFactory.openSession();
Query q = session.createCriteria(UserEntity.class)
    .add( Restrictions.like("id", input) )
    .list();
q.execute();</pre>
</p>
<br/>
<p>
<b>参考资料 (Hibernate)</b><br/>
<a href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/querycriteria.html">Hibernate Documentation: Query Criteria</a><br/>
<a href="https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Query.html">Hibernate Javadoc: Query Object</a><br/>
<a href="http://blog.h3xstream.com/2014/02/hql-for-pentesters.html">HQL for pentesters</a>: Guideline to test if the suspected code is exploitable.<br/>
<b>参考资料 (SQL 注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLIHIB">HQL注入</BugCode>

    <!-- JDOQL Injection -->
    <BugPattern type="SQL_INJECTION_JDO">
        <ShortDescription>潜在的SQL/JDOQL注入(JDO)</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL/JDOQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>
<p>
    <b>缺陷代码:</b><br/>
    <pre>
PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = " + input);
q.execute();</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>
PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = nameParam");
q.declareParameters("String nameParam");
q.execute(input);</pre>
</p>
<br/>
<p>
<b>参考资料 (JDO)</b><br/>
<a href="https://db.apache.org/jdo/object_retrieval.html">JDO: Object Retrieval</a><br/>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLIJDO">SQL注入(JDO)</BugCode>

    <!-- JPQL Injection -->
    <BugPattern type="SQL_INJECTION_JPA">
        <ShortDescription>潜在的SQL/JPQL注入(JPA)</ShortDescription>
        <LongDescription>{3}的使用容易受到SQL/JPQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>
<p>
    <b>缺陷代码:</b><br/>
    <pre>
EntityManager pm = getEM();

TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    String.format("select * from Users where name = %s", username),
    UserEntity.class);

UserEntity res = q.getSingleResult();</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>
TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    "select * from Users where name = usernameParam",UserEntity.class)
    .setParameter("usernameParam", username);

UserEntity res = q.getSingleResult();</pre>
</p>
<br/>
<p>
<b>参考资料 (JPA)</b><br/>
<a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbrg.html">The Java EE 6 Tutorial: Creating Queries Using the Java Persistence Query Language</a><br/>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLIJPA">SQL注入(JPA)</BugCode>


    <!-- SPRING JDBC Injection -->
    <BugPattern type="SQL_INJECTION_SPRING_JDBC">
        <ShortDescription>潜在的JDBC注入(Spring JDBC)</ShortDescription>
        <LongDescription>{3}的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>

<p>
    <b>缺陷代码:</b><br/>
    <pre>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = '"+paramName+"'", Integer.class);
</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = ?", Integer.class, paramName);</pre>
</p>
<br/>

<b>参考资料 (Spring JDBC)</b><br/>
<a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html">Spring Official Documentation: Data access with JDBC</a><br/>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLISPRJDBC">SQL注入(Spring JDBC)</BugCode>

    <!-- JDBC Injection -->
    <BugPattern type="SQL_INJECTION_JDBC">
        <ShortDescription>潜在的JDBC注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>

<p>
    <b>缺陷代码:</b><br/>
    <pre>Connection conn = [...];
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("update COFFEES set SALES = "+nbSales+" where COF_NAME = '"+coffeeName+"'");</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>Connection conn = [...];
conn.prepareStatement("update COFFEES set SALES = ? where COF_NAME = ?");
updateSales.setInt(1, nbSales);
updateSales.setString(2, coffeeName);</pre>
</p>
<br/>

<b>参考资料 (JDBC)</b><br/>
<a href="http://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html">Oracle Documentation: The Java Tutorials &gt; Prepared Statements</a><br/>
<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLIJDBC">SQL注入(JDBC)</BugCode>

    <!-- Scala Slick SQL Injection -->
    <BugPattern type="SCALA_SQL_INJECTION_SLICK">
        <ShortDescription>潜在的Scala Slick注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>

<p>
    <b>缺陷代码:</b><br/>
    <pre>db.run {
  sql"select * from people where name = '#$value'".as[Person]
}</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>db.run {
  sql"select * from people where name = $value".as[Person]
}</pre>
</p>
<br/>

<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSQLS">SQL注入(Scala - Slick)</BugCode>

    <!-- Scala Anorm SQL Injection -->
    <BugPattern type="SCALA_SQL_INJECTION_ANORM">
        <ShortDescription>潜在的Scala Anorm注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>

<p>
    <b>缺陷代码:</b><br/>
    <pre>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =>
  val people: List[Person] = SQL("select * from people where name = '" + value + "'").as(peopleParser.*)
}</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =>
  val people: List[Person] = SQL"select * from people where name = $value".as(peopleParser.*)
}</pre>
</p>
<br/>

<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSSQLA">SQL注入(Scala - Anorm)</BugCode>


    <!-- Android SQL Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.sql.AndroidSqlInjectionDetector">
        <Details>识别Android API中的各种SQL注入</Details>
    </Detector>

    <!-- Android SQL Injection -->
    <BugPattern type="SQL_INJECTION_ANDROID">
        <ShortDescription>潜在的Android SQL注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到SQL注入</LongDescription>
        <Details>
            <![CDATA[
<p>
SQL查询中包含的输入值需要安全地传递。预编译语句中的绑定变量可用于轻松降低SQL注入的风险。
</p>

<p>
    <b>缺陷代码:</b><br/>
    <pre>String query = "SELECT * FROM  messages WHERE uid= '"+userInput+"'" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,null);</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    <pre>String query = "SELECT * FROM  messages WHERE uid= ?" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,new String[] {userInput});</pre>
</p>
<br/>

<b>参考资料 (Android SQLite)</b><br/>
<a href="http://www.informit.com/articles/article.aspx?p=2268753&seqNum=5">InformIT.com: Practical Advice for Building Secure Android Databases in SQLite</a><br/>
<a href="https://www.packtpub.com/books/content/knowing-sql-injection-attacks-and-securing-our-android-applications-them">Packtpub.com: Knowing the SQL-injection attacks and securing our Android applications from them</a><br/>
<a href="https://books.google.ca/books?id=SXlMAQAAQBAJ&lpg=PR1&pg=PA64#v=onepage&q&f=false">Android Database Support (Enterprise Android: Programming Android Database Applications for the Enterprise)</a><br/>
<a href="https://stackoverflow.com/a/29797229/89769">Safe example of Insert, Select, Update and Delete queryies provided by Suragch</a><br/>

<b>参考资料 (SQL注入)</b><br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet">OWASP: Query Parameterization Cheat Sheet</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSQLITEA">SQLite Android API中的SQL注入</BugCode>


    <!-- LDAP Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.ldap.LdapInjectionDetector">
        <Details>识别JNDI和UnboundID APIs中的各种LDAP注入。</Details>
    </Detector>

    <BugPattern type="LDAP_INJECTION">
        <ShortDescription>潜在的LDAP注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到LDAP注入</LongDescription>
        <Details>
            <![CDATA[
<p>
和SQL一样, 传递给LDAP查询的所有输入都需要安全地传递。不幸的是, LDAP没有SQL那样的预编译语句接口。
因此, 对LDAP注入的主要防御手段是在将任何不受信任的数据放入LDAP查询语句之前对其进行强有力的输入验证。
</p>
<p>
    <b>有风险的代码:</b><br/>
    <pre>NamingEnumeration&lt;SearchResult&gt; answers = context.search("dc=People,dc=example,dc=com",
        "(uid=" + username + ")", ctrls);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246947/LDAP%20Injection">WASC-29: LDAP Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/90.html">CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</a><br/>
<a href="http://www.veracode.com/security/ldap-injection">LDAP Injection Guide: Learn How to Detect LDAP Injections and Improve LDAP Security</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECLDAPI">LDAP注入</BugCode>


    <!-- Script Engine Code injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.script.ScriptInjectionDetector">
        <Details>识别各种代码注入。</Details>
    </Detector>

    <BugPattern type="SCRIPT_ENGINE_INJECTION">
        <ShortDescription>使用Script Engine时的潜在代码注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到代码注入</LongDescription>
        <Details>
            <![CDATA[
<p>
    正在评估动态代码。 应该仔细分析代码构造。恶意代码执行可能导致数据泄漏或操作系统受损。
</p>
<p>
    如果要对用户代码进行评估，则应该使用适当的沙盒 (参阅参考资料)。
</p>

<p><b>有风险的代码:</b></p>
<p>
<pre>
public void runCustomTrigger(String script) {
    ScriptEngineManager factory = new ScriptEngineManager();
    ScriptEngine engine = factory.getEngineByName("JavaScript");

    engine.eval(script); //不好的事会在这里发生。
}</pre>
</p>

<p><b>解决方案:</b></p>
<p>
Safe evaluation of Javascript code using "Cloudbees Rhino Sandbox" library.<br/>
<pre>
public void runCustomTrigger(String script) {
    SandboxContextFactory contextFactory = new SandboxContextFactory();
    Context context = contextFactory.makeContext();
    contextFactory.enterContext(context);
    try {
        ScriptableObject prototype = context.initStandardObjects();
        prototype.setParentScope(null);
        Scriptable scope = context.newObject(prototype);
        scope.setPrototype(prototype);

        context.evaluateString(scope,script, null, -1, null);
    } finally {
        context.exit();
    }
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://github.com/cloudbees/rhino-sandbox">Cloudbees Rhino Sandbox</a>: Utility to create sandbox with Rhino (block access to all classes)<br/>
<a href="http://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/">CodeUtopia.net: Sandboxing Rhino in Java</a><br/>
<a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
<a href="http://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
<a href="https://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SCRIPTE">Script Engine注入</BugCode>

    <Detector class="com.h3xstream.findsecbugs.injection.script.SpelViewDetector">
        <Details>识别Spring组件中的SpelView模式。</Details>
    </Detector>

    <!-- SPEL Code injection -->
    <BugPattern type="SPEL_INJECTION">
        <ShortDescription>使用Spring表达式时潜在的代码注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到代码注入</LongDescription>
        <Details>
            <![CDATA[
<p>
    Spring表达式使用动态值构建。应验证这些值的来源，以避免未经过滤的值落入此风险代码评估中。
</p>
<p><b>有风险的代码:</b></p>
<p>
<pre>
public void parseExpressionInterface(Person personObj,String property) {

        ExpressionParser parser = new SpelExpressionParser();

        //如果输入可以由用户控制，这是不安全的..
        Expression exp = parser.parseExpression(property+" == 'Albert'");

        StandardEvaluationContext testContext = new StandardEvaluationContext(personObj);
        boolean result = exp.getValue(testContext, Boolean.class);
[...]</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
    <a href="http://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html">Spring Expression Language (SpEL) - Official Documentation</a><br/>
    <a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf">Minded Security: Expression Language Injection</a><br/>
    <a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
</p>

]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SPELI">Spring表达式语言注入</BugCode>

    <!-- EL Code injection -->
    <BugPattern type="EL_INJECTION">
        <ShortDescription>使用表达式语言(EL)时潜在的代码注入</ShortDescription>
        <LongDescription>{3} 的使用容易受到代码注入</LongDescription>
        <Details>
            <![CDATA[
<p>
    一个表达式是使用动态值创建的。应验证这些值的来源，以避免未经过滤的值落入此风险代码评估中。
</p>
<p><b>有风险的代码:</b></p>
<p>
<pre>public void evaluateExpression(String expression) {
    FacesContext context = FacesContext.getCurrentInstance();
    ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();
    ELContext elContext = context.getELContext();
    ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);
    return (String) vex.getValue(elContext);
}</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.html">Minded Security: Abusing EL for executing OS commands</a><br/>
    <a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">The Java EE 6 Tutorial: Expression Language</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
    <a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf">Minded Security: Expression Language Injection</a><br/>
    <a href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/">Dan Amodio's blog: Remote Code with Expression Language Injection</a><br/>
    <a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html">Remote Code Execution .. by design</a>: Example of malicious payload. The samples given could be used to test sandboxing rules.<br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECEL">表达式语言(EL)注入</BugCode>

    <!-- Seam Log injection -->
    <BugPattern type="SEAM_LOG_INJECTION">
        <ShortDescription>Seam日志记录调用时潜在的代码注入</ShortDescription>
        <LongDescription>Seam日志记录调用中潜在的代码注入</LongDescription>
        <Details>
            <![CDATA[
<p>
    Seam Logging API支持一种表达式语言，用于将bean属性引入日志消息。表达式语言也可能导致不必要的代码执行。
</p>
<p>
    在此上下文中，表达式使用动态值构建。 应验证这些值的来源，以避免未经过滤的值落入此风险代码评估中。
</p>
<p><b>有风险的代码:</b></p>
<p>
<pre>public void logUser(User user) {
    log.info("Current logged in user : " + user.getUsername());
    //...
}</pre>
</p>
<p><b>解决方案:</b></p>
<p>
<pre>public void logUser(User user) {
    log.info("Current logged in user : #0", user.getUsername());
    //...
}</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://issues.jboss.org/browse/JBSEAM-5130">JBSEAM-5130: Issue documenting the risk</a><br/>
    <a href="https://docs.jboss.org/seam/2.3.1.Final/reference/html_single/#d0e4185">JBoss Seam: Logging (Official documentation)</a><br/>
    <a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">The Java EE 6 Tutorial: Expression Language</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>

</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSEAM">表达式语言(EL)注入</BugCode>

    <!-- OGNL injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.script.OgnlInjectionDetector">
        <Details>识别OGNL注入。</Details>
    </Detector>

    <BugPattern type="OGNL_INJECTION">
        <ShortDescription>使用OGNL表达式时潜在的代码注入</ShortDescription>
        <LongDescription>使用OGNL表达式时潜在的代码注入</LongDescription>
        <Details>
            <![CDATA[
<p>
    一个表达式使用动态值构建。 应验证这些值的来源，以避免未经过滤的值落入此风险代码评估中。
</p>
<p><b>有风险的代码:</b></p>
<p>
<pre>
public void getUserProperty(String property) {
  [...]
  //第一个参数是动态表达式。
  return ognlUtil.getValue("user."+property, ctx, root, String.class);
}
</pre>
</p>
<p><b>解决方案:</b></p>
<p>
通常，评估OGNL表达式的方法不应接收用户输入。 它旨在用于静态配置和JSP。
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://community.saas.hpe.com/t5/Security-Research/Struts-2-OGNL-Expression-Injections/ba-p/288881">HP Enterprise: Struts 2 OGNL Expression Injections by Alvaro Mu&Atilde;&plusmn;oz</a><br/>
    <a href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html">Gotham Digital Science: An Analysis Of CVE-2017-5638</a><br/>
    <a href="http://struts.apache.org/docs/s2-016.html">Apache Struts2: Vulnerability S2-016</a><br/>
    <a href="https://struts.apache.org/docs/ognl.html">Apache Struts 2 Documentation: OGNL</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECOGNL">表达式语言(EL)注入</BugCode>


    <!-- HTTP Response Splitting -->
    <Detector class="com.h3xstream.findsecbugs.HttpResponseSplittingDetector">
        <Details>查找HTTP应答拆分弱点</Details>
    </Detector>

    <BugPattern type="HTTP_RESPONSE_SPLITTING">
        <ShortDescription>潜在的HTTP应答拆分</ShortDescription>
        <LongDescription>{3} 的使用可能导致HTTP报头中包含CRLF字符</LongDescription>
        <Details>
            <![CDATA[
<p>
    当HTTP请求包含非预期的CR和LF字符时, 服务器可能使用解释为两个不同HTTP响应（而不是一个）的输出流进行响应。
    攻击者可以控制第二个响应并加载攻击，例如跨站点脚本和缓存中毒攻击。
    根据OWASP，几乎所有现代Java EE应用程序服务器中都修复了该问题，但最好还是进行输入验证。
    如果您担心此风险，则应在所关注的平台上进行测试，以确定底层平台是否允许将CR或LF字符注入标头。
    报告此弱点的优先级低于SQL注入等，如果您使用的是易受攻击的平台，请检查低优先级警告。
</p>
<br/>
<p>
<b>有风险的代码:</b><br/>
<pre>String author = request.getParameter(AUTHOR_PARAMETER);
// ...
Cookie cookie = new Cookie("author", author);
response.addCookie(cookie);</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://www.owasp.org/index.php/HTTP_Response_Splitting">OWASP: HTTP Response Splitting</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/113.html">CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')</a>
    <a href="http://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
</p>

]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHRS">HTTP应答拆分</BugCode>


    <!-- CRLF injection in logs -->
    <Detector class="com.h3xstream.findsecbugs.injection.crlf.CrlfLogInjectionDetector">
        <Details>查找日志中的CRLF注入</Details>
    </Detector>

    <BugPattern type="CRLF_INJECTION_LOGS">
        <ShortDescription>日志中潜在的CRLF注入</ShortDescription>
        <LongDescription>{3} 使用可能导致日志消息中包含包含CRLF字符</LongDescription>
        <Details>
            <![CDATA[
<p>
    当来自不可信源的数据被放入日志记录器中，并且没有正确中和时，攻击者可以伪造日志条目或插入恶意内容。
    插入的虚假条目可用于扭曲统计数据，分散管理员的注意力，甚至可能暗示另一方参与恶意行为。
    如果自动处理日志文件，则攻击者可以通过破坏文件格式或注入非预期的字符来使文件无法使用。
    攻击者还可以将代码或其他命令注入日志文件，并利用日志处理实用程序中的漏洞（例如命令注入或XSS）。
</p>
<br/>
<p>
<b>有风险的代码:</b><br/>
<pre>String val = request.getParameter("user");
String metadata = request.getParameter("metadata");
[...]
if(authenticated) {
    log.info("User " + val + " (" + metadata + ") was authenticated successfully");
}
else {
    log.info("User " + val + " (" + metadata + ") was not authenticated");
}
</pre>

恶意用户可以使用以下值发送元数据参数：<code>"Firefox) was authenticated successfully\r\n[INFO] User bbb (Internet Explorer"</code>。
</p>

<b>解决方案:</b><br/>
<p>
您可以手动清理每个参数。
<pre>
log.info("User " + val.replaceAll("[\r\n]","") + " (" + userAgent.replaceAll("[\r\n]","") + ") was not authenticated");
</pre>
</p>

<p>
您还可以配置记录器服务以改变新消息事件的纪录。以下是LogBack <a href="https://logback.qos.ch/manual/layouts.html#replace">使用替换功能</a>的示例配置。
<pre>
&lt;pattern&gt;%-5level - %replace(%msg){'[\r\n]', ''}%n&lt;/pattern&gt;
</pre>
</p>

<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://cwe.mitre.org/data/definitions/117.html">CWE-117: Improper Output Neutralization for Logs</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
    <a href="https://logback.qos.ch/manual/layouts.html#replace">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
</p>

]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCRLFLOG">日志中的CRLF注入</BugCode>


    <!-- External control of system or configuration setting -->
    <Detector class="com.h3xstream.findsecbugs.ExternalConfigurationControlDetector">
        <Details>查找系统或配置设置的外部控制</Details>
    </Detector>

    <BugPattern type="EXTERNAL_CONFIG_CONTROL">
        <ShortDescription>配置的潜在外部控制</ShortDescription>
        <LongDescription>{3} 的使用可能导致配置的外部控制</LongDescription>
        <Details>
            <![CDATA[
<p>
    允许外部控制系统设置可能会中断服务或导致应用程序以意外和潜在的恶意方式运行。
    攻击者可能通过提供不存在的目录名称或连接到数据库的未授权部分而导致错误。
</p>
<br/>
<p>
<b>有风险的代码:</b><br/>
<pre>conn.setCatalog(request.getParameter("catalog"));</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://cwe.mitre.org/data/definitions/15.html">CWE-15: External Control of System or Configuration Setting</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCONFCTRL">配置的外部控制</BugCode>


    <!-- Bad Hexa -->
    <Detector class="com.h3xstream.findsecbugs.crypto.BadHexadecimalConversionDetector">
        <Details>识别toHexString、digest转换异常</Details>
    </Detector>
    <BugPattern type="BAD_HEXA_CONVERSION">
        <ShortDescription>toHexString、digest转换异常</ShortDescription>
        <LongDescription>使用toHexString、digest转换字节数组会出现异常</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b><br/>
<pre>
    使用digest、toHexString进行字节转换时，会出现0字符异常，如"0x0679"、"0x6709"被转换后都会变成"679";
</pre>
</p>
<br/>
<p>
    <b>错误代码:</b><br/>
<pre>
MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] resultBytes = md.digest(password.getBytes("UTF-8"));

StringBuilder stringBuilder = new StringBuilder();
for(byte b :resultBytes) {
    stringBuilder.append( Integer.toHexString( b & 0xFF ) );
}

return stringBuilder.toString();
</pre>
</p>
<br/>
<p>
    <b>解决方案:</b><br/>
<pre>
    stringBuilder.append( String.format( "%02X", b ) );
    使用上述函数进行转换处理。
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/704.html">CWE-704: Incorrect Type Conversion or Cast</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBHC">错误字符转换</BugCode>


    <!-- Hazelcast Symmetric encryption -->
    <Detector class="com.h3xstream.findsecbugs.crypto.HazelcastSymmetricEncryptionDetector">
        <Details>Hazelcast对称加密不安全</Details>
    </Detector>
    <BugPattern type="HAZELCAST_SYMMETRIC_ENCRYPTION">
        <ShortDescription>Hazelcast对称加密</ShortDescription>
        <LongDescription>Hazelcast的网络通信配置为使用对称密码</LongDescription>
        <Details>
            <![CDATA[
<p>Hazelcast的网络通信配置为使用对称密码(可能是DES或blowfish)。</p>
<p>这些密码本身不提供完整性或安全身份验证。最好使用非对称加密。</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a href="http://docs.hazelcast.org/docs/3.5/manual/html/encryption.html">Hazelcast Documentation: Encryption</a><br/>
<a href="http://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHAZ">Hazelcast对称加密</BugCode>


    <!-- NullCipher's use -->
    <Detector class="com.h3xstream.findsecbugs.crypto.NullCipherDetector">
        <Details>识别NullCipher的使用</Details>
    </Detector>
    <BugPattern type="NULL_CIPHER">
        <ShortDescription>NullCipher是不安全的</ShortDescription>
        <LongDescription>通常不希望使用NullCipher</LongDescription>
        <Details>
            <![CDATA[
<p>
在生产应用程序中，很少使用NullCipher。它通过返回与提供的明文相同的密文来实现Cipher接口。在一些情况下，例如测试的时候，NullCipher可能是合适的。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>Cipher doNothingCihper = new NullCipher();
[...]
//产生的密文与明文相同。
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>解决方案:</b><br/>
    避免使用NullCipher。 意外使用可能会带来严重的保密风险。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECNC">NullCipher</BugCode>


    <!-- Unencrypted Socket encryption -->
    <Detector class="com.h3xstream.findsecbugs.crypto.UnencryptedSocketDetector">
        <Details>未加密的套接字</Details>
    </Detector>
    <BugPattern type="UNENCRYPTED_SOCKET">
        <ShortDescription>未加密的套接字</ShortDescription>
        <LongDescription>未加密的套接字{0}（而不是SSLSocket）</LongDescription>
        <Details>
            <![CDATA[
<p>
所使用的通信信道未加密。拦截网络流量的攻击者可以读取该流量。
</p>
<p>
<b>缺陷代码:</b><br/>
Plain socket (Cleartext communication):
<pre>Socket soc = new Socket("www.google.com",80);</pre>
</p>
<p>
<b>解决方案:</b><br/>
SSL Socket (Secure communication):
<pre>Socket soc = SSLSocketFactory.getDefault().createSocket("www.google.com", 443);</pre>
</p>
<p>除了使用SSL套接字, 您需要确保您使用的SSLSocketFactory执行了所有相应的证书验证检查，以确保您不受中间人攻击。
请阅读OWASP传输层保护备忘单，了解有关如何正确执行此操作的详细信息。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A9">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
<a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">OWASP: Transport Layer Protection Cheat Sheet</a><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/319.html">CWE-319: Cleartext Transmission of Sensitive Information</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUS">未加密的套接字</BugCode>
    <!-- Unencrypted Server Socket encryption -->
    <Detector class="com.h3xstream.findsecbugs.crypto.UnencryptedServerSocketDetector">
        <Details>未加密的服务器端套接字</Details>
    </Detector>
    <BugPattern type="UNENCRYPTED_SERVER_SOCKET">
        <ShortDescription>未加密的服务器端套接字</ShortDescription>
        <LongDescription>未加密的服务器端套接字(而不是SSLServerSocket)</LongDescription>
        <Details>
            <![CDATA[
<p>
所使用的通信信道未加密。拦截网络流量的攻击者可以读取该流量。
</p>
<p>
<b>缺陷代码:</b><br/>
Plain server socket (Cleartext communication):
<pre>ServerSocket soc = new ServerSocket(1234);</pre>
</p>
<p>
<b>解决方案:</b><br/>
SSL Server Socket (Secure communication):
<pre>ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234);</pre>
</p>
<p>除了使用SSL服务器端套接字, 您需要确保您使用的SSLServerSocketFactory执行了所有相应的证书验证检查，以确保您不受中间人攻击。
请阅读OWASP传输层保护备忘单，了解有关如何正确执行此操作的详细信息。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A9">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
<a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">OWASP: Transport Layer Protection Cheat Sheet</a><br/>
<a href="http://projects.webappsec.org/w/page/13246945/Insufficient%20Transport%20Layer%20Protection">WASC-04: Insufficient Transport Layer Protection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/319.html">CWE-319: Cleartext Transmission of Sensitive Information</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUSS">未加密的服务器端套接字</BugCode>

    <!-- DES usage -->
    <Detector class="com.h3xstream.findsecbugs.crypto.cipher.DesUsageDetector">
        <Details>DES应该替换成AES</Details>
    </Detector>
    <BugPattern type="DES_USAGE">
        <ShortDescription>DES是不安全的</ShortDescription>
        <LongDescription>DES应该替换成AES</LongDescription>
        <Details>
            <![CDATA[
<p>
DES被认为是现代应用的强密码。目前，NIST建议使用AES分组密码而不是DES。
</p>
<p>
    <b>易受攻击代码的示例:</b>
<pre>Cipher c = Cipher.getInstance("DES/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>解决方案示例:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://www.nist.gov/itl/fips/060205_des.cfm">NIST Withdraws Outdated Data Encryption Standard</a><br/>
<a href="http://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECDU">DES</BugCode>

    <!-- TripleDES usage -->
    <Detector class="com.h3xstream.findsecbugs.crypto.cipher.TDesUsageDetector">
        <Details>DESede应该替换成AES</Details>
    </Detector>
    <BugPattern type="TDES_USAGE">
        <ShortDescription>DESede is insecure</ShortDescription>
        <LongDescription>DESede should be replaced with AES</LongDescription>
        <Details>
            <![CDATA[
<p>
三重DES（也称为3DES或DESede）被认为是现代应用的强密码。目前，NIST建议使用AES分组密码而不是DES。
</p>
<p>
    <b>易受攻击代码的示例:</b>
<pre>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>解决方案示例:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://www.nist.gov/itl/fips/060205_des.cfm">NIST Withdraws Outdated Data Encryption Standard</a><br/>
<a href="http://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECTDU">DESede</BugCode>

    <!-- RSA NoPadding -->
    <Detector class="com.h3xstream.findsecbugs.crypto.RsaNoPaddingDetector">
        <Details>没有适当填充的RSA密码</Details>
    </Detector>
    <BugPattern type="RSA_NO_PADDING">
        <ShortDescription>RSA使用NoPadding参数</ShortDescription>
        <LongDescription>RSA使用NoPadding作为参数存在不安全性</LongDescription>
        <Details>
            <![CDATA[
<p>
<b>危害:</b><br/>
<pre>
    RSA初始化使用NoPadding作为参数，加密后的数据易被破解；
</pre>
</p>
<br/>
<p>
<b>错误代码:</b><br/>
<pre>Cipher.getInstance("RSA/NONE/NoPadding")</pre>
</p>
<br/>
<p>
<b>解决方案:</b><br/>
<pre>
    RSA建议秘钥长度大于1024bit
    Cipher.getInstance("RSA/ECB/OAEPWithMD5AndMGF1Padding")
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/780.html">CWE-780: Use of RSA Algorithm without OAEP</a><br/>
<a href="http://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/">Root Labs: Why RSA encryption padding is critical</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRNP">RSA使用NoPadding参数</BugCode>

    <!-- Hard coded passwords and keys in various method calls -->
    <Detector class="com.h3xstream.findsecbugs.password.ConstantPasswordDetector">
        <Details>识别硬编码的密码和密钥</Details>
    </Detector>

    <!-- Hard coded Google API key -->
    <Detector class="com.h3xstream.findsecbugs.password.GoogleApiKeyDetector">
        <Details>识别硬编码的Google API密钥</Details>
    </Detector>

    <!-- Hard coded JNDI credentials and other password in map -->
    <Detector class="com.h3xstream.findsecbugs.password.HardcodePasswordInMapDetector">
        <Details>识别映射中的硬编码凭证</Details>
    </Detector>

    <Detector class="com.h3xstream.findsecbugs.password.IntuitiveHardcodePasswordDetector">
        <Details>识别自定义API中的硬编码凭证。</Details>
    </Detector>

    <Detector class="com.h3xstream.findsecbugs.password.HardcodedPasswordEqualsDetector">
        <Details>将名为password的变量与常量值进行比较时，识别硬编码凭据。</Details>
    </Detector>

    <BugPattern type="HARD_CODE_PASSWORD">
        <ShortDescription>密码硬编码</ShortDescription>
        <LongDescription>密码硬编码</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b>
<pre>
    客户端代码不可控，硬编码在代码中的密码（Password）易被逆向窃取；
</pre>
</p>
<br/>
<p>
<p><b>错误代码:</b><br/>
<pre>
	private String SECRET_PASSWORD = "letMeIn!";
	Properties props = new Properties();
	props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");
</pre>
</p>
<br/>
<p><b>解决方案:</b><br/>
<pre>
    密码不应该硬编码在源代码中，应该保存在独立的配置文件或keystore中；
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/259.html">CWE-259: Use of Hard-coded Password</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHCP">密码硬编码</BugCode>

<BugPattern type="HARD_CODE_KEY">
        <ShortDescription>密钥硬编码</ShortDescription>
        <LongDescription>密钥硬编码</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b>
<pre>
    客户端代码不可控，硬编码在代码中的密钥（Key）易被逆向窃取；
</pre>
</p>
<br/>
<p>
<p><b>错误代码:</b><br/>
<pre>byte[] key = {1, 2, 3, 4, 5, 6, 7, 8};
SecretKeySpec spec = new SecretKeySpec(key, "AES");
Cipher aes = Cipher.getInstance("AES");
aes.init(Cipher.ENCRYPT_MODE, spec);
return aesCipher.doFinal(secretData);</pre>
</p>
<br/>
<p><b>解决方案:</b><br/>
<pre>
    密钥不应该硬编码在源代码中，应该保存在独立的配置文件或keystore中；
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/321.html">CWE-321: Use of Hard-coded Cryptographic Key</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHCK">密钥硬编码</BugCode>


    <Detector class="com.h3xstream.findsecbugs.password.HashUnsafeEqualsDetector">
        <Details>不安全的hash比较容易遭到定时攻击。</Details>
    </Detector>

    <BugPattern type="UNSAFE_HASH_EQUALS">
        <ShortDescription>不安全的hash比较</ShortDescription>
        <LongDescription>不安全的hash比较容易遭到定时攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
由于比较时间的暴露，攻击者可能能够检测到秘密哈希的值。
当调用函数<code>Arrays.equals()</code>或<code>String.equals()</code>时，匹配的字符越少则函数越早退出。
</p>
<p>
<p><b>缺陷代码:</b><br/>

<pre>
String actualHash = ...

if(userInput.equals(actualHash)) {
    ...
}</pre>
</p>
<p><b>解决方案:</b><br/>

<pre>
String actualHash = ...

if(MessageDigest.isEqual(userInput.getBytes(),actualHash.getBytes())) {
    ...
}</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/203.html">CWE-203: Information Exposure Through DiscrepancyKey</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUHE">密钥硬编码</BugCode>


    <!-- Struts Form Validation -->
    <Detector class="com.h3xstream.findsecbugs.StrutsValidatorFormDetector">
        <Details>识别没有输入验证的Struts表单</Details>
    </Detector>
    <BugPattern type="STRUTS_FORM_VALIDATION">
        <ShortDescription>没有输入验证的Struts表单</ShortDescription>
        <LongDescription>没有输入验证的Struts表单</LongDescription>
        <Details>
            <![CDATA[
<p>
表单输入应该具有起码的输入验证。预防性验证有助于针对各种风险提供深度防御。
</p>
<p>
可以通过实现<code>validate</code>方法来引入验证。
<pre>
public class RegistrationForm extends ValidatorForm {

    private String name;
    private String email;

    [...]

    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {
        //通过HttpRequest传入的名称和电子邮件参数的验证代码在这里
    }
}
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a><br/>
<a href="http://cwe.mitre.org/data/definitions/106.html">CWE-106: Struts: Plug-in Framework not in Use</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSFV">没有输入验证的Struts表单</BugCode>


    <!-- XSS Filter -->
    <Detector class="com.h3xstream.findsecbugs.xss.XSSRequestWrapperDetector">
        <Details>识别XSSRequestWrapper (弱的XSS保护)</Details>
    </Detector>
    <BugPattern type="XSS_REQUEST_WRAPPER">
        <ShortDescription>XSSRequestWrapper是弱的XSS保护</ShortDescription>
        <LongDescription>XSSRequestWrapper是一种弱的XSS保护机制</LongDescription>
        <Details>
            <![CDATA[
<p>
在各种博客站点上发布了名为<code> XSSRequestWrapper </ code>的<code> HttpServletRequestWrapper </ code>的实现。
 <sup><a href="http://java.dzone.com/articles/stronger-anti-cross-site">[1]</a></sup>
<sup><a href="http://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html">[2]</a></sup>
</p>
<p>
由于以下原因，过滤器容易遭受攻击:
<ul>
<li>它仅涵盖参数，不包括标题或旁路输入</li>
<li>替换链可以轻松绕过（参见下面的示例）</li>
<li>它是基于黑名单而不是白名单</li>
</ul>
</p>
<p>
<b>绕过的示例:</b><br/>
</p>
<pre>&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</pre>
<p>
上述输入被转换成<b><code>"&lt;script&gt;alert(1)&lt;/script&gt;"</code></b>。
替换<code>"&lt;script&gt;.*&lt;/script&gt;"</code>之后，删除<code>"vbscript:"</code>。
</p>
<p>
为了获得更强的保护，请按照OWASP XSS预防备忘单中定义的XSS保护规则，在<b><u>视图</u></b>（template，jsp，...）中选择自动编码字符的解决方案。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXRW">XSSRequestWrapper(弱的XSS保护)</BugCode>


    <!-- Blowfish key size -->
    <Detector class="com.h3xstream.findsecbugs.crypto.InsufficientKeySizeBlowfishDetector">
        <Details>识别长度不够的Blowfish密钥</Details>
    </Detector>
    <BugPattern type="BLOWFISH_KEY_SIZE">
        <ShortDescription>Blowfish密钥长度太短</ShortDescription>
        <LongDescription>Blowfish密钥长度太短</LongDescription>
        <Details>
            <![CDATA[
<p>
Blowfish密码支持32位到448位的密钥。密钥长度太短将使密文容易遭受暴力破解攻击。
如果需要使用Blowfish，则在生成密钥时应使用至少128位熵。
</p>
<p>
如果需要更改算法，则应使用AES块密码。
</p>

<p><b>缺陷代码:</b><br/>
<pre>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(64);</pre>
</p>

<p><b>解决方案:</b><br/>
<pre>KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
keyGen.init(128);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish (cipher)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBKS">Blowfish密钥长度太短</BugCode>


    <!-- RSA key size -->
    <Detector class="com.h3xstream.findsecbugs.crypto.InsufficientKeySizeRsaDetector">
        <Details>识别长度不够的RSA密钥</Details>
    </Detector>
    <BugPattern type="RSA_KEY_SIZE">
        <ShortDescription>RSA密钥长度太短</ShortDescription>
        <LongDescription>RSA密钥长度太短</LongDescription>
        <Details>
            <![CDATA[
<p><b>危害:</b><br/>
<pre>
密钥长度小于768存在密文被破解的风险，官方建议密钥长度要大于2048位。
</pre>
</p>
<br/>
<p><b>问题代码:</b><br/>
<pre>
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(512);
</pre>
</p>
<br/>
<p><b>解决方案:</b><br/>
设置密钥长度大于2048.<br/>
<pre>
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://csrc.nist.gov/groups/ST/toolkit/key_management.html">NIST: Latest publication on key management</a><br/>
<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a><br/>
<a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/how-large-a-key-should-be-used.htm">RSA Laboratories: 3.1.5 How large a key should be used in the RSA cryptosystem?</a><br/>
<a href="http://en.wikipedia.org/wiki/Key_size#Asymmetric%5Falgorithm%5Fkey%5Flengths">Wikipedia: Asymmetric algorithm key lengths</a><br/>
<a href="http://cwe.mitre.org/data/definitions/326.html">CWE-326: Inadequate Encryption Strength</a><br/>
<a href="http://www.keylength.com/en/compare/">Keylength.com (BlueKrypt): Aggregate key length recommendations.</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECRKS">RSA密钥长度太短</BugCode>

    <!-- Unvalidated redirect -->
    <Detector class="com.h3xstream.findsecbugs.injection.redirect.UnvalidatedRedirectDetector">
        <Details>识别J2EE API中未验证的重定向</Details>
    </Detector>
    <Detector class="com.h3xstream.findsecbugs.scala.PlayUnvalidatedRedirectDetector">
        <Details>识别Play Framework (Scala)中未验证的重定向</Details>
    </Detector>

    <Detector class="com.h3xstream.findsecbugs.spring.SpringUnvalidatedRedirectDetector">
        <Details>识别Spring Framework中未验证的重定向</Details>
    </Detector>

    <BugPattern type="UNVALIDATED_REDIRECT">
        <ShortDescription>未验证的重定向</ShortDescription>
        <LongDescription>攻击者可以使用以下重定向将用户请求重定向到钓鱼网站。</LongDescription>
        <Details>
            <![CDATA[
<p>
    当目标URL中用户提供的参数未经验证时，将产生未经验证的重定向。此类漏洞可用于发起网络钓鱼攻击。
</p>
<p>
    <b>场景</b><br/>
    1. 用户被诱骗访问恶意URL：<code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. 用户被重定向到一个看起来可信任的网站的虚假登录页面。(<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. 用户输入他的凭证。<br/>
    4. 恶意网站窃取用户的凭据并将其重定向到原始网站。<br/>
    <br/>
    这种攻击似乎是合理的，因为大多数用户在重定向后不会重新确认URL。 此外，重定向到身份验证页面非常常见。
</p>
<p>
    <b>缺陷代码:</b></br/>
    <pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    [...]
    resp.sendRedirect(req.getParameter("redirectUrl"));
    [...]
}</pre>
</p>
<p>
    <b>解决方案/对策:</b><br/>
    <ul>
        <li>不接受用户的重定向目标</li>
        <li>接受目标密钥，并使用它来查找所需（合法）目标</li>
        <li>只接受相对路径</li>
        <li>URL白名单 (如果可能)</li>
        <li>验证URL的开头是否为白名单的一部分</li>
    </ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUR">未验证的重定向</BugCode>

    <BugPattern type="PLAY_UNVALIDATED_REDIRECT">
        <ShortDescription>未验证的重定向(Play Framework)</ShortDescription>
        <LongDescription>攻击者可以使用以下重定向将用户请求重定向到钓鱼网站。</LongDescription>
        <Details>
            <![CDATA[
<p>
    当目标URL中用户提供的参数未经验证时，将产生未经验证的重定向。此类漏洞可用于发起网络钓鱼攻击。
</p>
<p>
    <b>场景</b><br/>
    1. 用户被诱骗访问恶意URL：<code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. 用户被重定向到一个看起来可信任的网站的虚假登录页面。(<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. 用户输入他的凭证。<br/>
    4. 恶意网站窃取用户的凭据并将其重定向到原始网站。<br/>
    <br/>
    这种攻击似乎是合理的，因为大多数用户在重定向后不会重新确认URL。 此外，重定向到身份验证页面非常常见。
</p>
<p>
    <b>缺陷代码:</b></br/>
    <pre>def login(redirectUrl:String) = Action {
    [...]
    Redirect(url)
}</pre>
</p>
<p>
    <b>解决方案/对策:</b><br/>
    <ul>
        <li>不接受用户的重定向目标</li>
        <li>接受目标密钥，并使用它来查找所需（合法）目标</li>
        <li>只接受相对路径</li>
        <li>URL白名单 (如果可能)</li>
        <li>验证URL的开头是否为白名单的一部分</li>
    </ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPUR">未验证的重定向(Play Framewok)</BugCode>

    <BugPattern type="PLAY_UNVALIDATED_REDIRECT">
        <ShortDescription>未验证的重定向(Play Framework)</ShortDescription>
        <LongDescription>攻击者可以使用以下重定向将用户请求重定向到钓鱼网站。</LongDescription>
        <Details>
            <![CDATA[
<p>
    当目标URL中用户提供的参数未经验证时，将产生未经验证的重定向。此类漏洞可用于发起网络钓鱼攻击。
</p>
<p>
    <b>场景</b><br/>
    1. 用户被诱骗访问恶意URL：<code>http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</code><br/>
    2. 用户被重定向到一个看起来可信任的网站的虚假登录页面。(<code>http://evil.vvebsite.com/fake/login</code>)<br/>
    3. 用户输入他的凭证。<br/>
    4. 恶意网站窃取用户的凭据并将其重定向到原始网站。<br/>
    <br/>
    这种攻击似乎是合理的，因为大多数用户在重定向后不会重新确认URL。 此外，重定向到身份验证页面非常常见。
</p>
<p>
    <b>缺陷代码:</b></br/>
    <pre>def login(redirectUrl:String) = Action {
    [...]
    Redirect(url)
}</pre>
</p>
<p>
    <b>解决方案/对策:</b><br/>
    <ul>
        <li>不接受用户的重定向目标</li>
        <li>接受目标密钥，并使用它来查找所需（合法）目标</li>
        <li>只接受相对路径</li>
        <li>URL白名单 (如果可能)</li>
        <li>验证URL的开头是否为白名单的一部分</li>
    </ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246981/URL%20Redirector%20Abuse">WASC-38: URL Redirector Abuse</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br/>
<a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br/>
<a href="http://cwe.mitre.org/data/definitions/601.html">CWE-601: URL Redirection to Untrusted Site ('Open Redirect')</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECPUR">未验证的重定向(Play Framewok)</BugCode>


    <!-- JSP Include -->
    <Detector class="com.h3xstream.findsecbugs.jsp.JspIncludeDetector">
        <Details>识别JSP的include标签获取可由远程用户控制的动态输入。</Details>
    </Detector>
    <BugPattern type="JSP_INCLUDE">
        <ShortDescription>动态包含JSP文件</ShortDescription>
        <LongDescription>动态包含JSP文件可能导致任意代码的执行</LongDescription>
        <Details>
            <![CDATA[
<p>被包含的JSP文件允许输入动态值。可能导致包含的JSP页面被攻击者控制。
如果是这种情况，攻击者将尝试传入一个他可控制的磁盘文件。通过包含任意文件，攻击者可以执行任何代码。
</p>
<p>
    <b>缺陷代码:</b>
    <pre>&lt;jsp:include page="${param.secret_param}" /&gt;</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>&lt;c:if test="${param.secret_param == 'page1'}"&gt;
    &lt;jsp:include page="page1.jsp" /&gt;
&lt;/c:if&gt;</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://resources.infosecinstitute.com/file-inclusion-attacks/">InfosecInstitute: File Inclusion Attacks</a><br/>
<a href="http://projects.webappsec.org/w/page/13246955/Remote%20File%20Inclusion">WASC-05: Remote File Inclusion</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJSPINC">动态包含JSP文件</BugCode>

    <!-- Spring eval -->
    <Detector class="com.h3xstream.findsecbugs.jsp.JspSpringEvalDetector">
        <Details>识别Spring表达式中无意中使用的动态变量。</Details>
    </Detector>
    <BugPattern type="JSP_SPRING_EVAL">
        <ShortDescription>Spring表达式中的动态变量</ShortDescription>
        <LongDescription>Spring表达式中的动态变量可能导致任意代码的执行</LongDescription>
        <Details>
            <![CDATA[
<p>Spring表达式使用动态值构建。应验证值的来源，以避免未经过滤的值落入此风险代码评估中。</p>
<p>
    <b>缺陷代码:</b>
    <pre>&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %&gt;

&lt;spring:eval expression="${param.lang}" var="lang" /&gt;</pre>
    <br>
    <pre>&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %&gt;

&lt;spring:eval expression="'${param.lang}'=='fr'" var="languageIsFrench" /&gt;</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>&lt;c:set var="lang" value="${param.lang}"/&gt;</pre>
    <br/>
    <pre>&lt;c:set var="languageIsFrench" value="${param.lang == 'fr'}"/&gt;</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
    <a href="http://cwe.mitre.org/data/definitions/94.html">CWE-94: Improper Control of Generation of Code ('Code Injection')</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/95.html">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJSPSPRING">Spring表达式中的动态变量</BugCode>


    <!-- JSTL OUT -->
    <Detector class="com.h3xstream.findsecbugs.jsp.JstlOutDetector">
        <Details>检测禁用特殊XML字符转义的输出。</Details>
    </Detector>
    <BugPattern type="JSP_JSTL_OUT">
        <ShortDescription>特殊XML字符转义被禁用</ShortDescription>
        <LongDescription>特殊XML字符转义被禁用可能导致容易遭受XSS攻击</LongDescription>
        <Details>
            <![CDATA[
<p>找到一个潜在的XSS。它可以用于在客户端的浏览器中执行不必要的JavaScript。(参阅参考资料)
</p>
<p>
    <b>缺陷代码:</b>
    <pre>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;

&lt;c:out value="${param.test_param}" escapeXml="false"/&gt;</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;

&lt;c:out value="${param.test_param}"/&gt;</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a href="http://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/out.html">JSTL Javadoc: Out tag</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJSPJSTL">特殊XML字符转义被禁用</BugCode>

    <!-- XSS in JSP -->
    <Detector class="com.h3xstream.findsecbugs.xss.XssJspDetector">
        <Details>识别JSP中潜在的跨站点脚本。</Details>
    </Detector>
    <BugPattern type="XSS_JSP_PRINT">
        <ShortDescription>JSP中潜在的XSS</ShortDescription>
        <LongDescription>JSP中潜在的XSS</LongDescription>
        <Details>
            <![CDATA[
<p>找到一个潜在的XSS。它可以用于在客户端的浏览器中执行不必要的JavaScript。(参阅参考资料)
</p>
<p>
    <b>缺陷代码:</b>
    <pre><%
String taintedInput = (String) request.getAttribute("input");
%>
[...]
&lt;%= taintedInput %&gt;</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>
&lt;%
String taintedInput = (String) request.getAttribute("input");
%&gt;
[...]
&lt;%= Encode.forHtml(taintedInput) %&gt;
    </pre>
</p>
<p>
针对XSS的最佳防御是上下文敏感的输出编码，如上例所示。通常有4种情境需要考虑：HTML, JavaScript, CSS (styles), 以及 URLs。
请遵循OWASP XSS预防备忘单中定义的XSS保护规则，该规则详细解释了这些防御措施。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXSS1">JSP中潜在的XSS</BugCode>

    <Detector class="com.h3xstream.findsecbugs.xss.XssServletDetector">
        <Details>识别HttpServlet中潜在的跨站点脚本。</Details>
    </Detector>
    <!-- XSS in Servlet -->
    <BugPattern type="XSS_SERVLET">
        <ShortDescription>Servlet中潜在的XSS</ShortDescription>
        <LongDescription>{3} 的使用容易受到XSS攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
找到一个潜在的XSS。它可以用于在客户端的浏览器中执行不必要的JavaScript。(参阅参考资料)
</p>
<p>
    <b>缺陷代码:</b>
<pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(input1);
}</pre>
</p>
<p>
    <b>解决方案:</b>
<pre>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String input1 = req.getParameter("input1");
    [...]
    resp.getWriter().write(Encode.forHtml(input1));
}</pre>
</p>
<p>
针对XSS的最佳防御是上下文敏感的输出编码，如上例所示。通常有4种情境需要考虑：HTML, JavaScript, CSS (styles), 以及 URLs。
请遵循OWASP XSS预防备忘单中定义的XSS保护规则，该规则详细解释了这些防御措施。
</p>
<p>
请注意，此规则（Servlet中的XSS）查找类似的问题, 但查找的方式和FindBugs中的现有规则“XSS：有反射型跨站脚本漏洞的Servlet”
和“XSS：错误页面中有反射型跨站脚本漏洞的Servlet”不同。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXSS2">Servlet中潜在的XSS</BugCode>


    <!-- XML decoder -->
    <Detector class="com.h3xstream.findsecbugs.xml.XmlDecoderDetector">
        <Details>识别XMLDecoder(危险的XML反序列化程序)的使用。</Details>
    </Detector>
    <BugPattern type="XML_DECODER">
        <ShortDescription>使用XMLDecoder</ShortDescription>
        <LongDescription>使用XMLDecoder解析用户提供的数据是不安全的</LongDescription>
        <Details>
            <![CDATA[
<p>
    XMLDecoder不应用于解析不受信任的数据。反序列化用户输入可能导致任意代码的执行。
    这是有可能的，因为XMLDecoder支持任意方法的调用。此功能旨在调用setter方法，但实际上，可以调用任何方法。
</p>
<p>
    <b>恶意XML示例：</b>
</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt;
  &lt;object class="java.io.PrintWriter"&gt;
    &lt;string>/tmp/Hacked.txt&lt;/string&gt;
    &lt;void method="println"&gt;
      &lt;string>Hello World!&lt;/string&gt;
    &lt;/void&gt;
    &lt;void method="close"/&gt;
  &lt;/object&gt;
&lt;/java&gt;
</pre>
<p>
上面的XML代码将导致创建内容为“Hello World！”的文件。
</p>
<p>
    <b>缺陷代码:</b></br/>
    <pre>XMLDecoder d = new XMLDecoder(in);
try {
    Object result = d.readObject();
}
[...]</pre>
</p>
<p>
<b>解决方案:</b></br/>
解决方案就是避免使用XMLDecoder来解析来自不受信任的源的内容。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br/>
<a href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br/>
<a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="XMLDEC">使用XMLDecoder</BugCode>


    <!-- Static IV -->
    <Detector class="com.h3xstream.findsecbugs.crypto.StaticIvDetector">
        <Details>识别未正确生成的初始化向量（IV）。</Details>
    </Detector>
    <BugPattern type="STATIC_IV">
        <ShortDescription>静态IV</ShortDescription>
        <LongDescription>未正确生成初始化向量（IV）</LongDescription>
        <Details>
            <![CDATA[
<p>
    必须为每个要加密的消息重新生成初始化向量。
</p>
<p><b>缺陷代码:</b></p>
<p>
<pre>
private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};

public void encrypt(String message) throws Exception {

    IvParameterSpec ivSpec = new IvParameterSpec(IV);
[...]
</pre>
<p><b>解决方案:</b></p>
<p>
<pre>
public void encrypt(String message) throws Exception {

    byte[] iv = new byte[16];
    new SecureRandom().nextBytes(iv);

    IvParameterSpec ivSpec = new IvParameterSpec(iv);
[...]
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://en.wikipedia.org/wiki/Initialization_vector">Wikipedia: Initialization vector</a><br/>
<a href="http://cwe.mitre.org/data/definitions/329.html">CWE-329: Not Using a Random IV with CBC Mode</a><br/>
<a href="https://defuse.ca/cbcmodeiv.htm">Encryption - CBC Mode IV: Secret or Not?</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="STAIV">静态IV</BugCode>


    <!-- Ciphers with no integrity -->
    <BugPattern type="ECB_MODE">
        <ShortDescription>ECB模式不安全</ShortDescription>
        <LongDescription>密码使用ECB模式，加密数据的机密性较差</LongDescription>
        <Details>
            <![CDATA[
<p>应该使用为加密数据提供更好的机密性的认证密码模式来代替电子密码本（ECB）模式，ECB模式不提供良好的机密性。
具体来说，ECB模式每次为同一输入产生相同的输出。因此，例如，如果用户正在发送密码，则每次加密值都相同。 这就为攻击者拦截和重放数据提供便利。</p>
<p>
要解决这个问题，应该使用像Galois/Counter Mode（GCM）这样的模式。
</p>
<p>
<b>有风险的代码:</b>
    <pre>Cipher c = Cipher.getInstance("AES/ECB/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
<a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
<a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29">Wikipedia: Block cipher modes of operation</a><br/>
<a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">NIST: Recommendation for Block Cipher Modes of Operation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECECB">ECB模式</BugCode>


    <!-- Padding oracle -->
    <BugPattern type="PADDING_ORACLE">
        <ShortDescription>CBC/PKCS5Padding模式</ShortDescription>
        <LongDescription>CBC/PKCS5Padding模式无法抵御padding oracle attacks攻击</LongDescription>
        <Details>
<![CDATA[
<p>
    <b>危害:</b>
    <pre>
        CBC/PKCS5Padding模式无法抵御adding oracle attacks攻击，当暴露出在invalid padding 与 valid padding下明文的不同时，加密消息将会被解密。
    </pre>
</p>
<br/>
<p>
    <b>错误代码:</b>
    <pre>
    	Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, k, iv);
		byte[] cipherText = c.doFinal(plainText);
	</pre>
</p>
<br/>
<p>
    <b>解决方案:</b>
    使用GCM加密模式。
    <pre>Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
	c.init(Cipher.ENCRYPT_MODE, k, iv);
	byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf">Padding Oracles for the masses (by Matias Soler)</a><br/>
    <a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
    <a href="http://capec.mitre.org/data/definitions/463.html">CAPEC: Padding Oracle Crypto Attack</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/696.html">CWE-696: Incorrect Behavior Order</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="PADORA">CBC/PKCS5Padding模式</BugCode>


    <!-- Integrity missing -->
    <BugPattern type="CIPHER_INTEGRITY">
        <ShortDescription>加密无完整性校验</ShortDescription>
        <LongDescription>加密无数据完整性校验</LongDescription>
        <Details>
<![CDATA[
<p>
    <b>危害:</b>
    <pre>
        加密数据没有MAC值用于对数据完整性进行校验，导致加密后的数据能够被任意篡改，而加密算法并没有相关的校验机制。
    </pre>
</p>
<br/>
<p>下面这些加密模式均存在被攻击的风险，因为不存在HMAC校验:<br/>
    - CBC<br/>
    - OFB<br/>
    - CTR<br/>
    - ECB<br/><br/>
    <b>错误代码:</b><br/>
    <i>AES/CBC模式</i><br/>
    <pre>Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
    <br/>
    <i>DES/ECB模式</i><br/>
<pre>Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<p>
    <b>解决方案:</b>
    <pre>
    	使用GCM加密模式：
    	Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
c.init(Cipher.ENCRYPT_MODE, k, iv);
byte[] cipherText = c.doFinal(plainText);</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://en.wikipedia.org/wiki/Authenticated_encryption">Wikipedia: Authenticated encryption</a><br/>
    <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01">NIST: Authenticated Encryption Modes</a><br/>
    <a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">Moxie Marlinspike's blog: The Cryptographic Doom Principle</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/353.html">CWE-353: Missing Support for Integrity Check</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="CIPINT">加密无完整性校验</BugCode>


    <!-- ESAPI Encryptor -->
    <Detector class="com.h3xstream.findsecbugs.crypto.EsapiEncryptorDetector">
        <Details>识别ESAPI Encryptor的使用。</Details>
    </Detector>
    <BugPattern type="ESAPI_ENCRYPTOR">
        <ShortDescription>使用ESAPI Encryptor</ShortDescription>
        <LongDescription>ESAPI encryptor API用于加密数据</LongDescription>
        <Details>
<![CDATA[
<p>
    ESAPI在加密组件的历史中产生的漏洞很少。
    下面是一个快速验证列表，以确保Authenticated Encryption按预期工作。
</p>
<p><b>1. 库版本</b></p>
<p>
    在ESAPI版本2.1.0中，此问题已得到纠正。 版本号<= 2.0.1易受MAC旁路（CVE-2013-5679）的影响。<br/>
</p>
<p>
    对于Maven用户，可以使用以下命令调用插件<a href="http://mojo.codehaus.org/versions-maven-plugin/">versions</a>。
    ESAPI的有效版本将在输出中提供。<br/>
    <pre>$ mvn versions:display-dependency-updates</pre>
    <br/>输出：<br/>
    <pre>
[...]
[INFO] The following dependencies in Dependencies have newer versions:
[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -> 1.7.7
[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -> 2.1.0
[...]
    </pre>
</p>
<p>
    或直接查看配置。<br/>
    <pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;
    &lt;artifactId&gt;esapi&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
</p>
<p>
    对于Ant用户，使用的jar包应该是<a href="http://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar"> esapi-2.1.0.jar</A>。
</p>
<p><b>2. 配置：</b></p>
    <p>
    库版本2.1.0仍然容易受到密文定义（CVE-2013-5960）中更改密钥长度的影响。 需要采取一些预防措施。<br/>
    <br/>
    <div><b>如果存在任何这些要素，ESAPI的加密配置也可能容易受到攻击：</b><br/>
    <b>不安全的配置：</b><br/>
    <pre>
Encryptor.CipherText.useMAC=false

Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/CBC/PKCS5Padding

Encryptor.cipher_modes.additional_allowed=CBC</pre>
    </div>
</p>
<p>
    <div>
    <b>安全的配置：</b><br/>
    <pre>
#需要设置
Encryptor.CipherText.useMAC=true

#需要可靠的加密算法
Encryptor.EncryptionAlgorithm=AES
Encryptor.CipherTransformation=AES/GCM/NoPadding

#应该删除CBC模式以避免Padding Oracle
Encryptor.cipher_modes.additional_allowed=</pre>
    </div>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://owasp-esapi-java.googlecode.com/svn/trunk/documentation/ESAPI-security-bulletin1.pdf">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br/>
    <a href="http://nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5679">Vulnerability Summary for CVE-2013-5679</a><br/>
    <a href="http://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/310.html">CWE-310: Cryptographic Issues</a><br/>
    <a href="http://lists.owasp.org/pipermail/esapi-dev/2015-March/002533.html">ESAPI-dev mailing list: Status of CVE-2013-5960</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="ESAPIENC">ESAPI Encryptor</BugCode>


    <!-- Android: External File Access -->
    <Detector class="com.h3xstream.findsecbugs.android.ExternalFileAccessDetector">
        <Details>Identity file access on external storage.</Details>
    </Detector>
    <BugPattern type="ANDROID_EXTERNAL_FILE_ACCESS">
        <ShortDescription>外部文件存储(Android)</ShortDescription>
        <LongDescription>文件存储到外部SD卡中</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b><br/>
<pre>
任何具有SD卡访问权限的应用都可以访问该文件，易造成文件信息泄露。
</pre>
</p>
<br/>
<p>
    <b>错误代码:</b><br/>
<pre>
    getExternalCacheDir();
    getExternalCacheDirs();
    getExternalFilesDir("");
    getExternalFilesDirs("");
    getExternalMediaDirs();
    Environment.getExternalStorageDirectory();
    Environment.getExternalStoragePublicDirectory("");
</pre>
</p>
<br/>
<p>
    <b>解决方案:</b><br/>
<pre>
尽量不要将文件存储到外部SD卡中，特别是包含敏感信息文件，应存储到私有目录下。
</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://developer.android.com/training/articles/security-tips.html#ExternalStorage">Android Official Doc: Security Tips</a><br/>
    <a href="https://www.securecoding.cert.org/confluence/display/java/DRD00-J.+Do+not+store+sensitive+information+on+external+storage+%28SD+card%29+unless+encrypted+first">CERT: DRD00-J: Do not store sensitive information on external storage [...]</a><br/>
    <a href="http://developer.android.com/guide/topics/data/data-storage.html#filesExternal">Android Official Doc: Using the External Storage</a><br/>
    <a href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br/>
    <a href="https://cwe.mitre.org/data/definitions/312.html">CWE-312: Cleartext Storage of Sensitive Information</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECEFA">外部文件存储(Android)</BugCode>


    <!-- Android: Broadcast -->
    <Detector class="com.h3xstream.findsecbugs.android.BroadcastDetector">
        <Details>识别sendBroadcast()调用并给出安全隐患和有用的指导。</Details>
    </Detector>
    <BugPattern type="ANDROID_BROADCAST">
        <ShortDescription>发送广播消息未设置接受权限</ShortDescription>
        <LongDescription>发送广播消息时未设置接收权限或接收权限为NULL</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b><br/>
<pre>
    未设置接受权限，将导致广播被任意接受，可能造成敏感信息泄露；
</pre>
</p>
<br/>
<p>
    <b>错误代码:</b><br/>
<pre>
    sendBroadcast(intent);
    sendBroadcast(intent, null);
    sendBroadcastAsUser(intent, null);
    sendBroadcastAsUser(intent, null, null);

    sendOrderedBroadcast(intent, null);
    sendOrderedBroadcast(intent, null, null, null, 1, null, null);
    sendOrderedBroadcastAsUser(intent, null, null, null, null, 1, null, null);
</pre>
</p>
<br/>
<p>
    <b>解决方案:</b><br/>
<pre>
    在Manifest文件中定义Signature以上权限，并在发送广播消息是设置；
    使用LocalBroadcastManager发送广播消息，这样广播只能被本应用接收。
    sendBroadcast(intent);
    sendBroadcast(intent, "permission");
    sendBroadcastAsUser(intent, null);
    sendBroadcastAsUser(intent, null, "permission");

    sendOrderedBroadcast(intent, "permission");
    sendOrderedBroadcast(intent, "permission", null, null, 1, null, null);
    sendOrderedBroadcastAsUser(intent, null, "permission", null, null, 1, null, null);
</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://www.securecoding.cert.org/confluence/display/java/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent">CERT: DRD03-J. Do not broadcast sensitive information using an implicit intent</a><br/>
    <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#Security">Android Official Doc: BroadcastReceiver (Security)</a><br/>
    <a href="http://developer.android.com/guide/topics/manifest/receiver-element.html">Android Official Doc: Receiver configuration (see <code>android:permission</code>)</a><br/>
    <sup>[1]</sup> <a href="http://stackoverflow.com/a/21513368/89769">StackOverflow: How to set permissions in broadcast sender and receiver in android</a><br/>
    <a href="https://cwe.mitre.org/data/definitions/925.html">CWE-925: Improper Verification of Intent by Broadcast Receiver</a><br/>
    <a href="https://cwe.mitre.org/data/definitions/927.html">CWE-927: Use of Implicit Intent for Sensitive Communication</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBROAD">发送广播消息未设置接受权限</BugCode>


    <!-- Android: World Writable -->
    <Detector class="com.h3xstream.findsecbugs.android.WorldWritableDetector">
        <Details>识别使用创建模式MODE_WORLD_READABLE写入的文件。</Details>
    </Detector>
    <BugPattern type="ANDROID_WORLD_WRITABLE">
        <ShortDescription>创建模式使用不当</ShortDescription>
        <LongDescription>使用MODE_WORLD_READABLE、MODE_WORLD_WRITEABLE创建SharedPreference、文件、数据库</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b><br/>
<pre>
外部应用将会具有读取/写入该文件、文件夹的权限，易造成信息泄露、篡改。
</pre>
</p>
<br/>
<p>
    <b>错误代码:</b><br/>
<pre>
    getSharedP参考资料("key2", MODE_WORLD_READABLE|MODE_WORLD_WRITEABLE);
    openFileOutput("test_file3", Context.MODE_WORLD_READABLE|Context.MODE_WORLD_WRITEABLE);
    openOrCreateDatabase("privateNotSoSecure3",MODE_WORLD_READABLE|MODE_WORLD_WRITEABLE,null);
</pre>
</p>
<br/>
<p>
    <b>解决方案:</b><br/>
<pre>
创建文件：              openFileOutput();
创建SharedPreference： getSharedP参考资料();
创建数据库：            openOrCreateDatabase();
使用 MODE_PRIVATE 的方式进行创建。
</pre>
</p><br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://www.securecoding.cert.org/confluence/display/java/DRD11-J.+Ensure+that+sensitive+data+is+kept+secure">CERT: DRD11-J. Ensure that sensitive data is kept secure</a><br/>
    <a href="http://developer.android.com/training/articles/security-tips.html#InternalStorage">Android Official Doc: Security Tips</a><br/>
    <a href="http://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE">Android Official Doc: Context.MODE_PRIVATE</a><br/>
    <a href="http://www.vogella.com/tutorials/AndroidSQLite/article.html#databasetutorial_database">vogella.com: Android SQLite database and content provider - Tutorial</a><br/>
    <a href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br/>
    <a href="https://cwe.mitre.org/data/definitions/312.html">CWE-312: Cleartext Storage of Sensitive Information</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWW">创建模式使用不当</BugCode>


    <!-- Android: Geolocation -->
    <Detector class="com.h3xstream.findsecbugs.android.GeolocationDetector">
        <Details>识别Geolocation API的使用。</Details>
    </Detector>
    <BugPattern type="ANDROID_GEOLOCATION">
        <ShortDescription>已激活地理位置的WebView(Android)</ShortDescription>
        <LongDescription>已激活地理位置的WebView</LongDescription>
        <Details>
            <![CDATA[
<p>
    我们建议您要求用户确认获取地理位置信息。
</p>
<p>
    <b>有风险的代码:</b><br/>
<pre>
webView.setWebChromeClient(new WebChromeClient() {
    @Override
    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
        callback.invoke(origin, true, false);
    }
});
</pre>
</p>
<p>
    <b>建议代码:</b><br/>

    限制地理定位的抽样并要求用户确认。
<pre>
webView.setWebChromeClient(new WebChromeClient() {
    @Override
    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
        callback.invoke(origin, true, false);

        //要求用户确认
    }
});
</pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="https://www.securecoding.cert.org/confluence/display/java/DRD15-J.+Consider+privacy+concerns+when+using+Geolocation+API">CERT: DRD15-J. Consider privacy concerns when using Geolocation API</a><br/>
    <a href="http://en.wikipedia.org/wiki/W3C_Geolocation_API">Wikipedia: W3C Geolocation API</a><br/>
    <a href="http://dev.w3.org/geo/api/spec-source.html">W3C: Geolocation Specification</a><br/>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECGEO">地理位置(Android)</BugCode>


    <!-- Android: WebView with JavaScript Enabled -->
    <Detector class="com.h3xstream.findsecbugs.android.WebViewJavascriptEnabledDetector">
        <Details>识别启用了JavaScript的WebView。</Details>
    </Detector>
    <BugPattern type="ANDROID_WEB_VIEW_JAVASCRIPT">
        <ShortDescription>WebView设置不当</ShortDescription>
        <LongDescription>WebView JS File等设置不当</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>危害:</b><br/>
<pre>
    以上设置项设置为true，WebView将具有执行JS、访问文件、执行文件中JS脚本的权限，容易造成本地文件泄露、XSS等风险
</pre>
</p>
<br/>
<p>
    <b>错误代码:</b><br/>
<pre>
myWebView.getSettings().setJavaScriptEnabled(true);
myWebView.getSettings().setAllowFileAccess(true);
myWebView.getSettings().setAllowUniversalAccessFromFileURLs(true);
myWebView.getSettings().setAllowFileAccessFromFileURLs(true);
以上设置项设置为true，WebView将具有执行JS、访问文件、执行文件中JS脚本的权限，容易造成本地文件泄露、XSS等风险
</pre>
</p>
<br/>
<p>
    <b>解决方案:</b><br/>
<pre>
如不需要WebView具有执行JS的能力，设置myWebView.getSettings().setJavaScriptEnabled(false);
WebView一般不应该具有访问文件及执行文件中JS脚本的权限，将下面三个显著设置成false：
myWebView.getSettings().setAllowFileAccess(false);
myWebView.getSettings().setAllowUniversalAccessFromFileURLs(false);
myWebView.getSettings().setAllowFileAccessFromFileURLs(false);
</pre>
</p><br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://www.technotalkative.com/issue-using-setjavascriptenabled-can-introduce-xss-vulnerabilities-application-review-carefully/">Issue: Using setJavaScriptEnabled can introduce XSS vulnerabilities</a><br/>
    <a href="http://developer.android.com/guide/webapps/webview.html#UsingJavaScript">Android Official Doc: WebView</a><br/>
    <a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
    <a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
    <a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
    <a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWVJ">WebView设置不当</BugCode>


    <!-- Android:  -->
    <Detector class="com.h3xstream.findsecbugs.android.WebViewJavascriptInterfaceDetector">
        <Details>Identity WebView with a Java bridge (JavaScript Interface).</Details>
    </Detector>
    <BugPattern type="ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE">
        <ShortDescription>供JS调用的Java方法</ShortDescription>
        <LongDescription>供JS调用的Java本地方法</LongDescription>
        <Details>
            <![CDATA[
<p>
    <b>说明:</b><br/>
<pre>
    请谨慎设置这些能够被JS调用的Java方法，防止方法设置不当，对应用本身及手机造成危害；
</pre>
</p>
<p>
    <b>有风险的代码:</b><br/>
    <pre>
WebView myWebView = (WebView) findViewById(R.id.webView);

myWebView.addJavascriptInterface(new FileWriteUtil(this), "fileWriteUtil");

WebSettings webSettings = myWebView.getSettings();
webSettings.setJavaScriptEnabled(true);

[...]
class FileWriteUtil {
    Context mContext;

    FileOpenUtil(Context c) {
        mContext = c;
    }

    public void writeToFile(String data, String filename, String tag) {
        [...]
    }
}
    </pre>
</p>
<br/>
<p>
    <b>参考资料</b><br/>
    <a href="http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29">Android Official Doc: WebView.addJavascriptInterface()</a><br/>
    <a href="https://cwe.mitre.org/data/definitions/749.html">CWE-749: Exposed Dangerous Method or Function</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECWVJI">供JS调用的Java方法</BugCode>

    <!-- Cookie usage -->
    <Detector class="com.h3xstream.findsecbugs.cookie.CookieFlagsDetector">
        <Details>识别未设置安全标志的cookie</Details>
    </Detector>

    <BugPattern type="INSECURE_COOKIE">
        <ShortDescription>未设置安全标志的cookie</ShortDescription>
        <LongDescription>访问HTTP URL时没有安全标志的Cookie将以明文形式发送</LongDescription>
        <Details>
            <![CDATA[
<p>
在未设置<code>Secure</code>标志的情况下创建新cookie。
<code>Secure</code>标志是向浏览器发出的指令，以确保不在不安全的通信（<code>http://</code>）中发送cookie。
</p>

<p>
<b>有风险的代码:</b><br/>
<pre>
Cookie cookie = new Cookie("userName",userName);
response.addCookie(cookie);
</pre>
</p>

<p>
<b>解决方案 (具体设置):</b><br/>
<pre>
Cookie cookie = new Cookie("userName",userName);
cookie.setSecure(true); // Secure标志
cookie.setHttpOnly(true);
</pre>
</p>

<p>
<b>解决方案 (Servlet 3.0 的配置):</b><br/>
<pre>
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" version="3.0"&gt;
[...]
&lt;session-config&gt;
 &lt;cookie-config&gt;
  &lt;http-only&gt;true&lt;/http-only&gt;
  &lt;secure&gt;true&lt;/secure&gt;
 &lt;/cookie-config&gt;
&lt;/session-config&gt;
&lt;/web-app&gt;
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/614.html">CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute</a><br/>
<a href="https://cwe.mitre.org/data/definitions/315.html">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a><br/>
<a href="https://cwe.mitre.org/data/definitions/311.html">CWE-311: Missing Encryption of Sensitive Data</a><br/>
<a href="https://www.owasp.org/index.php/SecureFlag">OWASP: Secure Flag</a><br/>
<a href="https://www.rapid7.com/db/vulnerabilities/http-cookie-secure-flag">Rapid7: Missing Secure Flag From SSL Cookie</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECIC">未设置安全标志的cookie</BugCode>


    <BugPattern type="HTTPONLY_COOKIE">
        <ShortDescription>未设置HttpOnly标志的cookie</ShortDescription>
        <LongDescription>未设置HttpOnly标志的cookie可以被浏览器中的恶意脚本读取</LongDescription>
        <Details>
            <![CDATA[
<p>
在未设置<code>HttpOnly</code>标志的情况下创建新cookie。
<code>HttpOnly</code>标志是向浏览器发出的指令，以确保cookie不被恶意脚本读取。
比如当用户成为“跨站点脚本”的目标，攻击者将获取会话ID并从中获得利益。
</p>

<p>
<b>有风险的代码:</b><br/>
<pre>
Cookie cookie = new Cookie("email",userName);
response.addCookie(cookie);
</pre>
</p>

<p>
<b>解决方案 (具体设置):</b><br/>
<pre>
Cookie cookie = new Cookie("email",userName);
cookie.setSecure(true);
cookie.setHttpOnly(true); //HttpOnly标志
</pre>
</p>

<p>
<b>解决方案 (Servlet 3.0 设置):</b><br/>
<pre>
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" version="3.0"&gt;
[...]
&lt;session-config&gt;
 &lt;cookie-config&gt;
  &lt;http-only&gt;true&lt;/http-only&gt;
  &lt;secure&gt;true&lt;/secure&gt;
 &lt;/cookie-config&gt;
&lt;/session-config&gt;
&lt;/web-app&gt;
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://blog.codinghorror.com/protecting-your-cookies-httponly/">Coding Horror blog: Protecting Your Cookies: HttpOnly</a><br/>
<a href="https://www.owasp.org/index.php/HttpOnly">OWASP: HttpOnly</a><br/>
<a href="https://www.rapid7.com/db/vulnerabilities/http-cookie-http-only-flag">Rapid7: Missing HttpOnly Flag From Cookie</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHOC">未设置HttpOnly标志的cookie</BugCode>

    <!-- Deserialization vulnerability -->
    <Detector class="com.h3xstream.findsecbugs.serial.ObjectDeserializationDetector">
        <Details>对象反序列化检测器</Details>
    </Detector>

    <BugPattern type="OBJECT_DESERIALIZATION">
        <ShortDescription>使用了对象反序列化</ShortDescription>
        <LongDescription>{1}中使用了对象反序列化</LongDescription>
        <Details>
            <![CDATA[
<p>
    如果类路径中存在允许触发恶意操作的类，则不受信任数据的对象反序列化可能导致远程代码执行。
</p>
<p>
    库开发人员倾向于修复提供潜在恶意触发器的类。仍然有一些类可以触发拒绝服务<sup>[1]</sup>。
</p>
<p>
    反序列化是一种敏感的操作，历史上产生过很多漏洞。一旦Java虚拟机<sup>[2] [3]</sup>的一个新漏洞被发现，Web应用程序就可能变得容易受到攻击。
</p>

<p>
<b>有风险的代码:</b><br/>
<pre>
public UserData deserializeObject(InputStream receivedFile) throws IOException, ClassNotFoundException {

    try (ObjectInputStream in = new ObjectInputStream(receivedFile)) {
        return (UserData) in.readObject();
    }
}
</pre>
</p>

<p>
<b>解决方案:</b><br/>
<p>
避免反序列化远程用户提供的对象。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502: Deserialization of Untrusted Data</a><br/>
<a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">Deserialization of untrusted data</a><br/>
<a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html#8">Serialization and Deserialization </a><br/>
<a href="https://github.com/frohoff/ysoserial">A tool for generating payloads that exploit unsafe Java object deserialization</a><br/>
[1] <a href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d">Example of Denial of Service using the class java.util.HashSet</a><br/>
[2] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br/>
[3] <a href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECOBDES">使用了对象反序列化</BugCode>

    <!-- Deserialization vulnerability -->
    <Detector class="com.h3xstream.findsecbugs.serial.UnsafeJacksonDeserializationDetector">
        <Details>Jackson-databind对象反序列化检测器</Details>
    </Detector>

    <BugPattern type="JACKSON_UNSAFE_DESERIALIZATION">
        <ShortDescription>不安全的Jackson反序列化配置</ShortDescription>
        <LongDescription>{1} {2} {3}中使用了不安全的Jackson反序列化配置</LongDescription>
        <Details>
            <![CDATA[
<p>
当Jackson-databind库使用不正确时，如果类路径中存在允许触发恶意操作的类，则不受信任数据的反序列化可能导致远程代码执行。
</p>
<b>解决方案:</b><br/>
<p>
使用多态时，通过JsonTypeInfo.Id.NAME，来明确定义你想要的类型和子类型。
此外, 永远不要调用ObjectMapper.<strong>enableDefaultTyping</strong> (然后readValue一个类型包括Object，Serializable，Comparable以及一种已知的反序列化类型)。
</p>

<p>
<b>有风险的代码:</b><br/>
<pre>
public class Example {
    static class ABean {
        public int id;
        public Object obj;
    }

    static class AnotherBean {
        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) // 或 JsonTypeInfo.Id.MINIMAL_CLASS
        public Object obj;
    }

    public void example(String json) throws JsonMappingException {
         ObjectMapper mapper = new ObjectMapper();
         mapper.enableDefaultTyping();
         mapper.readValue(json, ABean.class);
    }

    public void exampleTwo(String json) throws JsonMappingException {
         ObjectMapper mapper = new ObjectMapper();
         mapper.readValue(json, AnotherBean.class);
    }

}
</pre>
</p>

<p>
<b>参考资料</b><br/>
<a href="https://github.com/FasterXML/jackson-databind/issues/1599">Jackson Deserializer security vulnerability</a><br>
<a href="https://github.com/mbechler/marshalsec">Java Unmarshaller Security - Turning your data into code execution</a><br>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECUJDES">没有安全地使用Jackson-databind。</BugCode>

    <!-- Deserialization vulnerability -->
    <Detector class="com.h3xstream.findsecbugs.serial.DeserializationGadgetDetector">
        <Details>识别导致使用序列化的应用程序容易遭受攻击的类。</Details>
    </Detector>

    <BugPattern type="DESERIALIZATION_GADGET">
        <ShortDescription>此类可用作反序列化小工具</ShortDescription>
        <LongDescription>此类将导致使用序列化的应用程序易受攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
反序列化小工具是一些类。攻击者利用这些类先进行反序列化，再通过本地序列化，这样就可以使用一个远程API。
此类要么使用readObject方法（Serializable）添加自定义的反序列化行为，要么被序列化对象(InvocationHandler)调用。
</p>
<p>
该探测器主要供研究人员使用。真正的问题是使用反序列化进行远程操作。
删除小工具是一种强化措施，可以降低被利用的风险。
</p>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502: Deserialization of Untrusted Data</a><br/>
<a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">Deserialization of untrusted data</a><br/>
<a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html#8">Serialization and Deserialization </a><br/>
<a href="https://github.com/frohoff/ysoserial">A tool for generating payloads that exploit unsafe Java object deserialization</a><br/>
[1] <a href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d">Example of Denial of Service using the class java.util.HashSet</a><br/>
[2] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br/>
[3] <a href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECDESGAD">反序列化小工具</BugCode>


    <!-- Trust Boundary Violation -->
    <Detector class="com.h3xstream.findsecbugs.injection.trust.TrustBoundaryViolationValueDetector">
        <Details>检测潜在的对会话属性值（Trust Boundary Violation）的不必要访问。</Details>
    </Detector>
    <Detector class="com.h3xstream.findsecbugs.injection.trust.TrustBoundaryViolationAttributeDetector">
        <Details>检测潜在的对会话属性名（Trust Boundary Violation）的不必要访问。</Details>
    </Detector>

    <BugPattern type="TRUST_BOUNDARY_VIOLATION">
        <ShortDescription>信任边界违规</ShortDescription>
        <LongDescription>该应用程序在会话属性中混合可信和不可信数据。</LongDescription>
        <Details>
            <![CDATA[
<p>
    "信任边界可以被认为是通过程序绘制的线。在线的一侧，数据是不可信的。
    在线的另一侧，数据被认为是值得信赖的。验证逻辑的目的是允许数据安全地跨越信任边界 - 从不受信任转移到受信任。
    当程序模糊信任内容和不信任内容之间的界线时，就会发生信任边界违规。
    通过在相同的数据结构中组合可信和不可信的数据，程序员更容易错误地信任未经验证的数据。" <sup>[1]</sup>
</p>

<p>
<b>有风险的代码:</b><br/>
<pre>
public void doSomething(HttpServletRequest req, String activateProperty) {
    //..

    req.getSession().setAttribute(activateProperty,"true");

}
</pre>
<br/>
<pre>
public void loginEvent(HttpServletRequest req, String userSubmitted) {
    //..

    req.getSession().setAttribute("user",userSubmitted);
}
</pre>
</p>

<p>
<b>解决方案:</b><br/>
<p>
解决方案是在设置新的会话属性之前添加验证。 如果可能，请选择安全位置的数据，而不是直接使用用户输入的数据。
</p>
<br/>
<p>
<b>参考资料</b><br/>
[1] <a href="https://cwe.mitre.org/data/definitions/501.html">CWE-501: Trust Boundary Violation</a><br/>
<a href="https://www.owasp.org/index.php/Trust_Boundary_Violation">OWASP : Trust Boundary Violation</a>
</p>
]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECTBV">信任边界违规</BugCode>

    <!-- JSP XSLT -->
    <Detector class="com.h3xstream.findsecbugs.jsp.XslTransformJspDetector">
        <Details>识别在JSP中完成的XSL转换。</Details>
    </Detector>
    <BugPattern type="JSP_XSLT">
        <ShortDescription>可提供恶意XSLT</ShortDescription>
        <LongDescription>可以提供恶意XSLT来触发远程代码执行</LongDescription>
        <Details>
            <![CDATA[
<p>
    "XSLT（可扩展样式表语言转换）是一种将XML文档转换为其他XML文档的语言"。<sup>[1]</sup><br/>
    恶意行为可能被附加到这些样式表。因此，如果攻击者可以控制样式表的内容或来源，他可能会触发远程代码执行。<sup>[2]</sup>
</p>
<p>
<b>有风险的代码:</b><br/>
<pre>
&#x3C;x:transform xml=&#x22;${xmlData}&#x22; xslt=&#x22;${xsltControlledByUser}&#x22; /&#x3E;
</pre>
</p>
<p>
<b>解决方案:</b><br/>
<p>
解决方案是确保样式表是从安全的源加载的，并确保不存在路径遍历<sup>[3][4]</sup>等漏洞。
</p>
<p>
<b>参考资料</b><br/>
[1] <a href="https://en.wikipedia.org/wiki/XSLT">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br/>
<a href="https://prezi.com/y_fuybfudgnd/offensive-xslt/">Offensive XSLT</a> by Nicolas Gregoire<br/>
[2] <a href="http://www.agarri.fr/kom/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br/>
<a href="http://xhe.myxwiki.org/xwiki/bin/view/Main/">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br/>
<a href="http://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br/>
<a href="https://www.w3.org/TR/xslt">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br/>
[3] <a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
[4] <a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECJSPXSLT">可提供恶意XSLT</BugCode>

    <!-- XSLT -->
    <Detector class="com.h3xstream.findsecbugs.xml.StdXmlTransformDetector">
        <Details>识别XSL转换。</Details>
    </Detector>
    <BugPattern type="MALICIOUS_XSLT">
        <ShortDescription>可提供恶意XSLT</ShortDescription>
        <LongDescription>可以提供恶意XSLT来触发远程代码执行</LongDescription>
        <Details>
            <![CDATA[
<p>
    "XSLT（可扩展样式表语言转换）是一种将XML文档转换为其他XML文档的语言"。<sup>[1]</sup><br/>
    恶意行为可能被附加到这些样式表。因此，如果攻击者可以控制样式表的内容或来源，他可能会触发远程代码执行。<sup>[2]</sup>
</p>
<p>
<b>有风险的代码:</b><br/>
<pre>
Source xslt = new StreamSource(new FileInputStream(inputUserFile)); //需要验证的危险源

Transformer transformer = TransformerFactory.newInstance().newTransformer(xslt);

Source text = new StreamSource(new FileInputStream("/data_2_process.xml"));
transformer.transform(text, new StreamResult(...));
</pre>
</p>
<p>
<b>解决方案:</b><br/>
<p>
解决方案是确保样式表是从安全的源加载的，并确保不存在路径遍历<sup>[3][4]</sup>等漏洞。
</p>
<p>
<b>参考资料</b><br/>
[1] <a href="https://en.wikipedia.org/wiki/XSLT">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br/>
<a href="https://prezi.com/y_fuybfudgnd/offensive-xslt/">Offensive XSLT</a> by Nicolas Gregoire<br/>
[2] <a href="http://www.agarri.fr/kom/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br/>
<a href="http://xhe.myxwiki.org/xwiki/bin/view/Main/">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br/>
<a href="http://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br/>
<a href="https://www.w3.org/TR/xslt">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br/>
[3] <a href="http://projects.webappsec.org/w/page/13246952/Path%20Traversal">WASC: Path Traversal</a><br/>
[4] <a href="https://www.owasp.org/index.php/Path_Traversal">OWASP: Path Traversal</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECXSLT">可提供恶意XSLT</BugCode>

    <!-- Scala sensitive data leak -->
    <Detector class="com.h3xstream.findsecbugs.scala.ScalaSensitiveDataExposureDetector">
        <Details>识别Scala Play中潜在的信息泄漏</Details>
    </Detector>
    <BugPattern type="SCALA_SENSITIVE_DATA_EXPOSURE">
        <ShortDescription>Scala Play中潜在的信息泄漏</ShortDescription>
        <LongDescription>Scala Play中发现的配置或系统信息泄漏</LongDescription>
        <Details>
            <![CDATA[
<p>
    应用程序可能无意中通过各种应用程序问题泄露关于其配置、内部工作或侵犯隐私的信息。<sup>[1]</sup>
    根据数据的有效性提供不同响应的页面可能导致信息泄漏;特别是因为Web应用程序的设计，当被视为机密的数据做为结果显示时。<sup>[2]</sup>
</p>
<p>
    敏感数据的示例(不仅限于): API 密钥, 密码, 产品版本号 或 环境配置。
</p>
<p>
<b>有风险的代码:</b><br/>
<pre>def doGet(value:String) = Action {
  val configElement = configuration.underlying.getString(value)

  Ok("Hello "+ configElement +" !")
}</pre>
</p>
<p>
    不应在响应内容中发送应用程序配置元素，并且不应允许用户通过代码控制将使用哪些配置元素。
</p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br/>
[1] <a href="https://www.owasp.org/index.php/Top_10_2007-Information_Leakage_and_Improper_Error_Handling">OWASP: Top 10 2007-Information Leakage and Improper Error Handling</a><br/>
[2] <a href="http://projects.webappsec.org/w/page/13246936/Information%20Leakage">WASC-13: Information Leakage</a><br/>
<a href="https://cwe.mitre.org/data/definitions/200.html">CWE-200: Information Exposure</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSDL">配置或系统信息泄漏</BugCode>

    <!-- Scala Play Server Side Request Forgery -->
    <Detector class="com.h3xstream.findsecbugs.scala.SSRFDetector">
        <Details>识别潜在的Scala Play服务器端请求伪造（SSRF）</Details>
    </Detector>
    <BugPattern type="SCALA_PLAY_SSRF">
        <ShortDescription>Scala Play服务器端请求伪造(SSRF)</ShortDescription>
        <LongDescription>攻击者可以使用此Web服务器请求来公开内部服务。</LongDescription>
        <Details>
            <![CDATA[
<p>
    当Web服务器对未经验证的用户提供的地址参数执行请求时，会发生服务器端请求伪造。此类漏洞可能允许攻击者访问内部服务或从您的Web服务器发起攻击。
</p>
<p>
    <b>缺陷代码:</b>
<pre>def doGet(value:String) = Action {
    WS.url(value).get().map { response =>
        Ok(response.body)
    }
}</pre>
</p>
<p>
    <b>解决方案/对策：</b><br/>
    <ul>
        <li>不接受用户的请求地址</li>
        <li>接受一个地址键, 并用它来查找目标(合法的)地址</li>
        <li>URL白名单(如果可能的话)</li>
        <li>验证URL的开头部分是否再白名单中</li>
    </ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918: Server-Side Request Forgery (SSRF)</a><br/>
<a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/">Understanding Server-Side Request Forgery</a><br/>
</p>
            ]]></Details>
    </BugPattern>
    <BugCode abbrev="SECSSSRF">Scala Play服务器端请求伪造</BugCode>
	
    <BugPattern type="URLCONNECTION_SSRF_FD">
        <ShortDescription>URLConnection服务器端请求伪造（SSRF）和文件披露</ShortDescription>
        <LongDescription>攻击者可以使用此Web服务器请求来公开内部服务和文件系统。</LongDescription>
        <Details>
            <![CDATA[
<p>
    当Web服务器对未经验证的用户提供的目标参数执行请求时，会发生服务器端请求伪造。 
	此类漏洞可能允许攻击者访问内部服务或从您的Web服务器发起攻击。
</p>
<p>
    URLConnection可以与file：//协议或其他协议一起使用，以访问本地文件系统和其他可能的服务。
<p>
    <b>缺陷代码:</b>
<pre>
new URL(String url).openConnection()
new URL(String url).openStream()
new URL(String url).getContent()
</pre>
</p>
<p>
    <b>解决方案/对策:</b><br/>
    <ul>
        <li>不接受用户的请求地址</li>
        <li>接受一个地址键, 并用它来查找目标(合法的)地址</li>
        <li>URL白名单(如果可能的话)</li>
        <li>验证URL的开头部分是否再白名单中</li>
    </ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918: Server-Side Request Forgery (SSRF)</a><br/>
<a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/">Understanding Server-Side Request Forgery</a><br/>
<a href="https://cwe.mitre.org/data/definitions/73.html">CWE-73: External Control of File Name or Path</a><br/>
<a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/">Abusing jar:// downloads</a><br />
</p>
            ]]></Details>
    </BugPattern>
    <BugCode abbrev="SECSSSRFUC">URLConnection服务器端请求伪造</BugCode>

    <!-- XSS in Scala Play Twirl template engine -->
    <Detector class="com.h3xstream.findsecbugs.scala.XssTwirlDetector">
        <Details>识别Scala Twirl模板引擎中潜在的跨站脚本。</Details>
    </Detector>
    <BugPattern type="SCALA_XSS_TWIRL">
        <ShortDescription>Scala Twirl模板引擎中潜在的XSS</ShortDescription>
        <LongDescription>{3} 的使用容易遭受XSS攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
找到一个潜在的XSS。它可用于在客户端的浏览器中执行不需要的JavaScript。(参阅参考资料)
</p>
<p>
    <b>缺陷代码:</b>
<pre>@(value: Html)

@value</pre>
</p>
<p>
    <b>解决方案:</b>
<pre>@(value: String)

@value</pre>
</p>
<p>
针对XSS的最佳防御是上下文敏感的输出，像上面的例子那样编码。通常有4种情境需要考虑：
HTML, JavaScript, CSS (styles), 以及 URLs。请遵循OWASP XSS预防备忘单中定义的XSS保护规则，该规则详细解释了这些防御措施。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSXSST">Scala Twirl中潜在的XSS</BugCode>

    <!-- XSS in Scala Play controller response -->
    <Detector class="com.h3xstream.findsecbugs.scala.XssMvcApiDetector">
        <Details>识别Scala MVC API引擎中潜在的跨站脚本。</Details>
    </Detector>
    <BugPattern type="SCALA_XSS_MVC_API">
        <ShortDescription>Scala MVC API引擎中潜在的XSS</ShortDescription>
        <LongDescription>具有此content-type的MVC结果可能容易受到XSS的攻击</LongDescription>
        <Details>
            <![CDATA[
<p>
找到一个潜在的XSS。它可用于在客户端的浏览器中执行不需要的JavaScript。(参阅参考资料)
</p>
<p>
    <b>缺陷代码:</b>
<pre>def doGet(value:String) = Action {
    Ok("Hello " + value + " !").as("text/html")
  }</pre>
</p>
<p>
    <b>解决方案:</b>
<pre>def doGet(value:String) = Action {
    Ok("Hello " + Encode.forHtml(value) + " !")
  }</pre>
</p>
<p>
针对XSS的最佳防御是上下文敏感的输出，像上面的例子那样编码。通常有4种情境需要考虑：
HTML, JavaScript, CSS (styles), 以及 URLs。请遵循OWASP XSS预防备忘单中定义的XSS保护规则，该规则详细解释了这些防御措施。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting">WASC-8: Cross Site Scripting</a><br/>
<a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP: XSS Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br/>
<a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a><br/>
<a href="https://code.google.com/p/owasp-java-encoder/">OWASP Java Encoder</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSXSS">Scala MVC API中潜在的XSS</BugCode>

    <!-- Potential template injection with Velocity -->
    <Detector class="com.h3xstream.findsecbugs.template.VelocityDetector">
        <Details>识别Velocity模板引擎的使用。</Details>
    </Detector>
    <BugPattern type="TEMPLATE_INJECTION_VELOCITY">
        <ShortDescription>潜在的使用Velocity的模板注入</ShortDescription>
        <LongDescription>潜在的使用Velocity模板的模板注入</LongDescription>
        <Details>
            <![CDATA[
<p>
Velocity模板引擎是很强大的。它可以添加条件语句，循环和外部调用等逻辑。
它不是设计为用于模板操作的沙箱。控制模板的恶意用户可以在服务器端运行恶意代码。Velocity模板应该被视为脚本。
</p>
<p>
    <b>缺陷代码:</b>
<pre>[...]

Velocity.evaluate(context, swOut, "test", userInput);</pre>
</p>
<p>
    <b>解决方案:</b>
<br/>
避免让最终用户使用Velocity操作模板。如果您需要向用户演示模版编辑,
最好使用无逻辑的模板引擎，如Handlebars或Moustache (参阅参考资料)。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://blog.portswigger.net/2015/08/server-side-template-injection.html">PortSwigger: Server-Side Template Injection </a><br/>
<a href="https://jknack.github.io/handlebars.java/">Handlebars.java</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECVELO">潜在的使用Velocity的模板注入</BugCode>

    <!-- Potential template injection with Freemarker -->
    <Detector class="com.h3xstream.findsecbugs.template.FreemarkerDetector">
        <Details>识别Freemarker模板引擎的使用。</Details>
    </Detector>
    <BugPattern type="TEMPLATE_INJECTION_FREEMARKER">
        <ShortDescription>潜在的使用Freemarker的模板注入</ShortDescription>
        <LongDescription>潜在的使用Freemarker模板的模板注入</LongDescription>
        <Details>
            <![CDATA[
<p>
Freemarker模板引擎是很强大的。它可以添加条件语句，循环和外部调用等逻辑。
它不是设计为用于模板操作的沙箱。控制模板的恶意用户可以在服务器端运行恶意代码。Freemarker模板应该被视为脚本。
</p>
<p>
    <b>缺陷代码:</b>
<pre>Template template = cfg.getTemplate(inputTemplate);
[...]
template.process(data, swOut);</pre>
</p>
<p>
    <b>解决方案:</b>
<br/>
避免让最终用户使用Freemarker操作模板。如果您需要向用户演示模版编辑,
最好使用无逻辑的模板引擎，如Handlebars或Moustache (参阅参考资料)。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://blog.portswigger.net/2015/08/server-side-template-injection.html">PortSwigger: Server-Side Template Injection </a><br/>
<a href="https://jknack.github.io/handlebars.java/">Handlebars.java</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECFREEM">潜在的使用Freemarker的模板注入</BugCode>


    <!-- Overly permissive CORS policy -->
    <Detector class="com.h3xstream.findsecbugs.PermissiveCORSDetector">
        <Details>检测过度宽松的CORS策略。</Details>
    </Detector>

    <BugPattern type="PERMISSIVE_CORS">
        <ShortDescription>过度宽松的CORS策略</ShortDescription>
        <LongDescription>该程序定义了一种过度宽松的跨源资源共享（CORS）策略</LongDescription>
        <Details>
            <![CDATA[
<p>
在HTML5之前，Web浏览器强制实施同源策略，即为了使JavaScript能够访问网页的内容，JavaScript和Web页面必须来自同一个域。
如果没有同源策略，恶意网站可以提供JavaScript，使用客户端的凭据从其他网站加载敏感信息，剔除它，并将其传回给攻击者。
如果定义了名为Access-Control-Allow-Origin的新HTTP标头，HTML5使JavaScript可以跨域访问数据。使用此标头，Web服务器定义允许哪些其他域使用跨源请求访问其域。
但是，在定义标头时应该小心，因为过度宽松的CORS策略将允许恶意应用程序以不适当的方式与受害应用程序通信，从而导致欺骗，数据窃取，中继和其他攻击。
</p>
<p>
    <b>缺陷代码:</b>
<pre>response.addHeader("Access-Control-Allow-Origin", "*");</pre>
</p>
<p>
    <b>解决方案:</b>
<br/>
避免使用*作为Access-Control-Allow-Origin标头的值，这表示应用程序的数据可供任何域上运行的JavaScript访问。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.w3.org/TR/cors/">W3C Cross-Origin Resource Sharing</a><br/>
<a href="http://enable-cors.org/">Enable Cross-Origin Resource Sharing</a><br/>
</p>]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCORS">过度宽松的CORS策略</BugCode>

    <!-- LDAP anonymous bind detector -->
    <Detector class="com.h3xstream.findsecbugs.ldap.AnonymousLdapDetector">
        <Details>标识匿名LDAP绑定的使用</Details>
    </Detector>
    <BugPattern type="LDAP_ANONYMOUS">
        <ShortDescription>匿名的LDAP绑定</ShortDescription>
        <LongDescription>匿名的LDAP绑定</LongDescription>
        <Details>
            <![CDATA[
<p>
如果没有适当的访问控制，执行包含用户可控的值的LDAP语句，将导致攻击者滥用配置不当的LDAP环境。针对ctx执行的所有LDAP查询都将在没有身份验证和访问控制的情况下执行。
攻击者可能以某种意想不到的方式操纵其中一个查询，以获取受目录的访问控制机制保护的记录的访问权限。
</p>
<p>
    <b>缺陷代码:</b>
<pre>...
env.put(Context.SECURITY_AUTHENTICATION, "none");
DirContext ctx = new InitialDirContext(env);
...</pre>
</p>
<p>
    <b>解决方案:</b>
<br/>
考虑LDAP的其他身份验证模式，并确保正确的访问控制机制。

</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html">Ldap Authentication Mechanisms</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="LDAPA">匿名的LDAP绑定</BugCode>

    <!-- LDAP Entry Poisoning -->
    <Detector class="com.h3xstream.findsecbugs.ldap.LdapEntryPoisoningDetector">
        <Details>识别允许LDAP Entry Poisoning的错误配置</Details>
    </Detector>
    <BugPattern type="LDAP_ENTRY_POISONING">
        <ShortDescription>LDAP Entry Poisoning</ShortDescription>
        <LongDescription>LDAP Entry Poisoning</LongDescription>
        <Details>
            <![CDATA[
<p>
JNDI API支持在LDAP目录中绑定序列化对象。如果某些属性被显示，则将在查询目录的应用程序中进行对象的反序列化。（有关详细信息，请参阅Black Hat USA 2016白皮书）。
应将对象反序列化视为可能导致远程代码执行的危险操作。
</p>
<p>
如果攻击者在LDAP基本查询中具有入口点，通过向现有LDAP条目添加属性或将应用程序配置为使用恶意LDAP服务器，则可以利用此漏洞。
</p>
<p>
    <b>缺陷代码:</b>
<pre>
DirContext ctx = new InitialDirContext();
//[...]

ctx.search(query, filter,
        new SearchControls(scope, countLimit, timeLimit, attributes,
            true, //Enable object deserialization if bound in directory
            deref));
</pre>
</p>
<p>
    <b>解决方案:</b>
<pre>
DirContext ctx = new InitialDirContext();
//[...]

ctx.search(query, filter,
        new SearchControls(scope, countLimit, timeLimit, attributes,
            false, //Disable
            deref));
</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf">Black Hat USA 2016: A Journey From JNDI/LDAP Manipulation to Remote Code Execution Dream Land</a>
(<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">slides</a> &amp; <a href="https://www.youtube.com/watch?v=Y8a5nB-vy78">video</a>) by Alvaro Mu&#xF1;oz and Oleksandr Mirosh<br/>
<a href="https://community.hpe.com/t5/Security-Research/Introducing-JNDI-Injection-and-LDAP-Entry-Poisoning/ba-p/6885118">HP Enterprise: Introducing JNDI Injection and LDAP Entry Poisoning</a> by Alvaro Mu&#xF1;oz<br/>
<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/">TrendMicro: How The Pawn Storm Zero-Day Evaded Java's Click-to-Play Protection</a> by Jack Tang
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECLDAPEP">LDAP Entry Poisoning</BugCode>

    <!-- Persistent Cookie Usage-->
    <Detector class="com.h3xstream.findsecbugs.cookie.PersistentCookieDetector">
        <Details>识别持久性cookie的使用</Details>
    </Detector>
    <BugPattern type="COOKIE_PERSISTENT">
        <ShortDescription>使用持久性cookie</ShortDescription>
        <LongDescription>Cookie设置为在1年或更长时间内过期</LongDescription>
        <Details>
            <![CDATA[
<p>
将敏感数据长时间存储在持久性cookie中可能会导致机密性破坏或帐户泄露。
</p>
<p>
    <b>解释:</b><br/>
如果私有信息存储在持久性cookie中，则攻击者有更大的时间窗口来窃取这些数据 - 特别是因为持久性cookie通常被设置为在遥远的将来到期。
持久性cookie通常存储在客户端上的文本文件中，对受害者计算机具有访问权限的攻击者可以窃取此信息。<br/>
持久性cookie通常用于在用户与网站交互时对用户进行分析。根据对此跟踪数据的处理方式，可以使用持久性Cookie来侵犯用户的隐私。
</p>
<p>
    <b>缺陷代码:</b> 以下代码将cookie设置为在1年后到期。<br/>
<pre>[...]
Cookie cookie = new Cookie("email", email);
cookie.setMaxAge(60*60*24*365);
[...]</pre>
</p>
<p>
    <b>解决方案:</b><br/>
<ul>
    <li>仅在必要时使用持久性cookie并限制其最长期限。</li>
    <li>不要将持久性cookie用于敏感数据。</li>
</ul>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/Cookie.html#setMaxAge%28int%29">Class Cookie setMaxAge documentation</a><br/>
<a href="https://cwe.mitre.org/data/definitions/539.html">CWE-539: Information Exposure Through Persistent Cookies</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECCP">使用持久性cookie</BugCode>


    <!-- URL Rewriting Methods -->
    <Detector class="com.h3xstream.findsecbugs.cookie.UrlRewritingDetector">
        <Details>检测URL重写方法。</Details>
    </Detector>

    <BugPattern type="URL_REWRITING">
        <ShortDescription>URL重写方法</ShortDescription>
        <LongDescription>方法将会话ID重写到URL中</LongDescription>
        <Details>
            <![CDATA[
<p>
该方法的实现包括确定是否需要在URL中编码会话ID的逻辑<br/>
URL重写具有重大的安全风险。由于如果会话ID出现在URL中，第三方可能很容易看到它。URL中的会话ID可以通过多种方式公开，例如：<br/>
<ul>
    <li>日志文件,</li>
    <li>浏览器的历史纪录,</li>
    <li>通过将其复制并粘贴或发布到电子邮件,</li>
    <li>HTTP Referrer.</li>
</ul>
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>out.println("Click &lt;a href=" + 
                res.encodeURL(HttpUtils.getRequestURL(req).toString()) + 
                "&gt;here&lt;/a&gt;");</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免使用那些方法。如果您要编码URL或表单参数，请不要将URL重写方法与URLEncoder类混淆。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Top_10_2010-A3-Broken_Authentication_and_Session_Management">OWASP Top 10 2010-A3-Broken Authentication and Session Management</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECURLR">URL重写方法</BugCode>


    <!-- Insecure SMTP SSL connection -->
    <Detector class="com.h3xstream.findsecbugs.crypto.InsecureSmtpSslDetector">
        <Details>检测不安全的SMTP SSL连接。</Details>
    </Detector>

    <BugPattern type="INSECURE_SMTP_SSL">
        <ShortDescription>不安全的SMTP SSL连接</ShortDescription>
        <LongDescription>此SMTP SSL连接没有验证服务器证书</LongDescription>
        <Details>
            <![CDATA[
<p>
进行SSL连接时服务器身份验证被禁用。某些启用SSL连接的电子邮件库默认情况下不检验服务器证书。这相当于信任所有证书。
当尝试连接到服务器时，此应用程序将很容易接受发布到"hackedserver.com"的证书。现在，应用程序可能会在与被黑客服务器的连接断开时泄漏敏感的用户信息。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>...
Email email = new SimpleEmail();
email.setHostName("smtp.servermail.com");
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator(username, password));
email.setSSLOnConnect(true);
email.setFrom("user@gmail.com");
email.setSubject("TestMail");
email.setMsg("This is a test mail ... :-)");
email.addTo("foo@bar.com");
email.send();
...</pre>
</p>
<p>
    <b>解决方案:</b><br/>
请添加以下检查以验证服务器证书：
<pre>email.setSSLCheckServerIdentity(true);</pre>
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/297.html">CWE-297: Improper Validation of Certificate with Host Mismatch</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECISC">不安全的SMTP SSL连接</BugCode>


    <!-- AWS Query Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.aws.AwsQueryInjectionDetector">
        <Details>检测AWS查询注入。</Details>
    </Detector>

    <BugPattern type="AWS_QUERY_INJECTION">
        <ShortDescription>AWS查询注入</ShortDescription>
        <LongDescription>此SimpleDB客户端接受来自不受信任来源的数据。</LongDescription>
        <Details>
            <![CDATA[
<p>
构造包含用户输入的SimpleDB查询，将允许攻击者查看未经授权的记录。<br/>
以下示例动态构造并执行SimpleDB select()查询，它允许用户指定productCategory。攻击者可以修改查询，绕过customerID所需的身份验证并查看与任何客户匹配的记录。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>...
String customerID = getAuthenticatedCustomerID(customerName, customerCredentials);
String productCategory = request.getParameter("productCategory");
...
AmazonSimpleDBClient sdbc = new AmazonSimpleDBClient(appAWSCredentials);
String query = "select * from invoices where productCategory = '"
            + productCategory + "' and customerID = '"
            + customerID + "' order by '"
            + sortColumn + "' asc";
SelectResult sdbResult = sdbc.select(new SelectRequest(query));
</pre>
</p>
<p>
    <b>解决方案:</b><br/>
此问题类似于SQL注入。在SimpleDB查询中使用之前净化用户输入。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/943.html">CWE-943: Improper Neutralization of Special Elements in Data Query Logic</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECAQI">AWS查询注入</BugCode>


    <!-- JavaBeans Property Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.beans.BeanInjectionDetector">
        <Details>检测JavaBeans Property设值注入</Details>
    </Detector>

    <BugPattern type="BEAN_PROPERTY_INJECTION">
        <ShortDescription>JavaBeans Property设值注入</ShortDescription>
        <LongDescription>JavaBeans属性名称使用用户控制的参数填充</LongDescription>
        <Details>
            <![CDATA[
<p>
攻击者可以设置任何可能危及系统完整性的bean属性。Bean填充函数允许设置bean属性或嵌套属性。攻击者可以利用此功能访问特殊bean属性，比如class。
classLoader将允许他覆盖系统属性并可能执行任意代码。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>MyBean bean = ...;
HashMap map = new HashMap();
Enumeration names = request.getParameterNames();
while (names.hasMoreElements()) {
    String name = (String) names.nextElement();
    map.put(name, request.getParameterValues(name));
}
BeanUtils.populate(bean, map);</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免使用用户控制的值来填充Bean属性名称。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/15.html">CWE-15: External Control of System or Configuration Setting</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECBPI">JavaBeans Property设值注入</BugCode>


    <!-- Struts and Spring File Disclosure -->
    <Detector class="com.h3xstream.findsecbugs.injection.fileDisclosure.FileDisclosureDetector">
        <Details>检测Struts和Spring文件披露</Details>
    </Detector>
    
    <!-- Struts File Disclosure -->
    <BugPattern type="STRUTS_FILE_DISCLOSURE">
        <ShortDescription>Struts文件披露</ShortDescription>
        <LongDescription>使用用户控制的参数填充ActionForward</LongDescription>
        <Details>
            <![CDATA[
<p>
使用用户输入构造服务器端重定向路径，可能允许攻击者下载应用程序二进制文件（包括应用程序类或jar文件）或查看受保护目录中的任意文件。<br/>
攻击者可能伪造请求参数以匹配敏感文件位置。例如, 请求"http://example.com/?returnURL=WEB-INF/applicationContext.xml"将显示应用程序的applicationContext.xml文件。
攻击者可以找到并下载其他配置文件中引用的applicationContext.xml，甚至是类文件或jar文件，获取敏感信息并启动其他类型的攻击。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>... 
String returnURL = request.getParameter("returnURL"); 
Return new ActionForward(returnURL); 
...</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免使用用户控制的输入构建服务器端重定向。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSFD">Struts文件披露</BugCode>

    <!-- Spring File Disclosure -->
    <BugPattern type="SPRING_FILE_DISCLOSURE">
        <ShortDescription>Spring文件披露</ShortDescription>
        <LongDescription>使用用户控制的参数填充ModelAndView</LongDescription>
        <Details>
            <![CDATA[
<p>
使用用户输入构造服务器端重定向路径，可能允许攻击者下载应用程序二进制文件（包括应用程序类或jar文件）或查看受保护目录中的任意文件。<br/>
攻击者可能伪造请求参数以匹配敏感文件位置。例如, 请求"http://example.com/?returnURL=WEB-INF/applicationContext.xml"将显示应用程序的applicationContext.xml文件。
攻击者可以找到并下载其他配置文件中引用的applicationContext.xml，甚至是类文件或jar文件，获取敏感信息并启动其他类型的攻击。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>... 
String returnURL = request.getParameter("returnURL");
return new ModelAndView(returnURL); 
...</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免使用用户控制的输入构建服务器端重定向。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSF">Spring文件披露</BugCode>

    <!-- RequestDispatcher File Disclosure -->
    <BugPattern type="REQUESTDISPATCHER_FILE_DISCLOSURE">
        <ShortDescription>RequestDispatcher文件披露</ShortDescription>
        <LongDescription>使用用户控制的参数填充的RequestDispatcher</LongDescription>
        <Details>
            <![CDATA[
<p>
使用用户输入构造服务器端重定向路径,可能允许攻击者下载应用程序二进制文件（包括应用程序类或jar文件）或查看受保护目录中的任意文件。<br/>
攻击者可能伪造请求参数以匹配敏感文件位置。例如，请求"http://example.com/?jspFile=../applicationContext.xml%3F"将显示应用程序的applicationContext.xml文件。
攻击者可以找到并下载其他配置文件中引用的applicationContext.xml，甚至是类文件或jar文件，获取敏感信息并启动其他类型的攻击。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>...
String jspFile = request.getParameter("jspFile");
request.getRequestDispatcher("/WEB-INF/jsps/" + jspFile + ".jsp").include(request, response);
...</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免使用用户控制的输入构建服务器端重定向。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/552.html">CWE-552: Files or Directories Accessible to External Parties</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSFDR">RequestDispatcher文件披露</BugCode>

    <!-- Format String Manipulation -->
    <Detector class="com.h3xstream.findsecbugs.injection.formatter.FormatStringManipulationDetector">
        <Details>检测格式字符串参数中的用户输入。</Details>
    </Detector>

    <BugPattern type="FORMAT_STRING_MANIPULATION">
        <ShortDescription>操纵格式字符串</ShortDescription>
        <LongDescription>允许用户控制参数的格式字符串参数</LongDescription>
        <Details>
            <![CDATA[
<p>
允许用户输入控制格式参数，将使攻击者能够引发异常或泄露信息。<br/>
攻击者可能修改格式字符串参数，以便抛出异常。如果此异常未被捕获，则可能会使应用程序崩溃。或者，如果在未使用的参数中使用敏感信息，攻击者可能会更改格式字符串以显示此信息。<br/>
下面的示例代码允许用户指定显示余额的小数点。实际上，用户可以指定任何内容以导致抛出异常，来使应用程序崩溃。
在此示例中更严重的是，如果攻击者可以指定用户输入"2f %3$s %4$.2"，则格式字符串将为"客户：%s %s的余额为 %4$.2f %3$s %4$.2"。这将导致敏感的accountNo被包含在结果字符串中。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>Formatter formatter = new Formatter(Locale.US);
String format = "The customer: %s %s has the balance %4$." + userInput + "f";
formatter.format(format, firstName, lastName, accountNo, balance);</pre>
</p>
<p>
    <b>解决方案:</b><br/>
避免在格式字符串参数中使用用户控制的值。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="http://cwe.mitre.org/data/definitions/134.html">CWE-134: Use of Externally-Controlled Format String</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECFSM">操纵格式字符串</BugCode>


    <!-- HTTP Parameter Pollution -->
    <Detector class="com.h3xstream.findsecbugs.injection.http.HttpParameterPollutionDetector">
        <Details>检测将用户控制的输入连接到URL。</Details>
    </Detector>

    <BugPattern type="HTTP_PARAMETER_POLLUTION">
        <ShortDescription>HTTP参数污染</ShortDescription>
        <LongDescription>将用户控制的输入连接到URL</LongDescription>
        <Details>
            <![CDATA[
<p>
将未经验证的用户输入连接到URL，将允许攻击者覆盖请求参数的值。攻击者将能够覆盖现有参数值，注入新参数或利用不能直接获取的变量。
HTTP参数污染(HPP)攻击通过将编码的查询字符串分隔符注入到其他现有参数中。如果Web应用程序未正确处理用户输入，则恶意用户可能会破坏应用程序的逻辑以执行客户端或服务器端攻击。<br/>
在下面的示例中，程序员没有考虑攻击者可以提供诸如en＆user_id = 1之类的lang的可能性，这将使他能够随意更改user_id。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>String lang = request.getParameter("lang");
GetMethod get = new GetMethod("http://www.host.com");
get.setQueryString("lang=" + lang + "&user_id=" + user_id);
get.execute();</pre>
<p>
    <b>解决方案:</b><br/>
在HTTP参数中使用之前净化用户输入。
</p>
<br/>
<p>
<b>参考资料</b><br/>
<a href="https://capec.mitre.org/data/definitions/460.html">CAPEC-460: HTTP Parameter Pollution (HPP)</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECHPP">HTTP参数污染</BugCode>


    <Detector class="com.h3xstream.findsecbugs.PotentialValueDetector">
        <Details>如果动态参数为null，帮助其他检测器查找使用的硬编码值。</Details>
    </Detector>

    <!-- ErrorMessageDetector -->
    <Detector class="com.h3xstream.findsecbugs.crypto.ErrorMessageExposureDetector">
        <Details>通过错误消息检测可能的信息泄露。
        </Details>
    </Detector>

    <BugPattern type="INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE">
        <ShortDescription>通过错误消息进行信息公开</ShortDescription>
        <LongDescription>通过错误消息暴露可能的信息</LongDescription>
        <Details>
            <![CDATA[
<p>
敏感信息本身可能是有价值的信息（例如密码），或者对于发起其他更致命的攻击可能是有用的。
如果攻击失败，攻击者可能会使用服务器提供的错误信息来启动另一个更集中的攻击。
例如，尝试利用路径遍历弱点（CWE-22）可能会产生已安装应用程序的完整路径名。反过来，通过选择适当数量的“..”序列可以导航到目标文件。
使用SQL注入（CWE-89）的攻击最初可能不会成功，但错误消息可能会显示格式错误的查询，这会暴露查询逻辑，甚至可能暴露查询中使用的密码或其他敏感信息。
</p>
<p>
    <b>缺陷代码:</b><br/>
<pre>try {
  out = httpResponse.getOutputStream()
} catch (Exception e) {
  e.printStackTrace(out);
}</pre>

<p>
<b>参考资料</b><br/>
<a href="https://cwe.mitre.org/data/definitions/209.html">CWE-209: Information Exposure Through an Error Message</a>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="ERRMSG">通过错误消息进行信息公开</BugCode>

    <!-- SMTP Header Injection -->
    <Detector class="com.h3xstream.findsecbugs.injection.smtp.SmtpHeaderInjectionDetector">
        <Details>检测SMTP标头中可能的注入。(Email)</Details>
    </Detector>

    <BugPattern type="SMTP_HEADER_INJECTION">
        <ShortDescription>SMTP标头注入</ShortDescription>
        <LongDescription>可能导致源欺骗，标题覆盖和电子邮件正文注入的注入。</LongDescription>
        <Details>
            <![CDATA[
<p>
简单邮件传输协议（SMTP）是一种用于电子邮件传递的基于文本的协议。与HTTP一样，标题由新行分隔符分隔。
如果用户输入位于标题行中，则应用程序应删除或替换换行符（CR / LF）。
您应该使用安全包装，例如<a href="https://commons.apache.org/proper/commons-email/userguide.html">Apache Common Email</a>
和<a href="http://www.simplejavamail.org">Simple Java Mail</a>，它们可以过滤可能导致标题注入的特殊字符。

</p>
    <b>缺陷代码:</b><br/>
<p>
<pre>
Message message = new MimeMessage(session);
message.setFrom(new InternetAddress("noreply@your-organisation.com"));
message.setRecipients(Message.RecipientType.TO, new InternetAddress[] {new InternetAddress("target@gmail.com")});
message.setSubject(usernameDisplay + " has sent you notification"); //Injectable API
message.setText("Visit your ACME Corp profile for more info.");
Transport.send(message);
</pre>
</p>
    <b>解决方案</b><br/>
<p>使用<a href="https://commons.apache.org/proper/commons-email/userguide.html">Apache Common Email</a>或者<a href="http://www.simplejavamail.org">Simple Java Mail</a>。</p>

<p>
<b>参考资料</b><br/>
<a href="https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011)">OWASP SMTP Injection</a><br/>
<a href="https://cwe.mitre.org/data/definitions/93.html">CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')</a><br/>
<a href="https://commons.apache.org/proper/commons-email/userguide.html">Commons Email: User Guide</a><br/>
<a href="http://www.simplejavamail.org">Simple Java Mail Website</a><br/>
<a href="https://security.stackexchange.com/a/54100/24973">StackExchange InfoSec: What threats come from CRLF in email generation?</a><br/>
</p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECSMTP">SMTP标头注入</BugCode>

    <Detector class="com.h3xstream.findsecbugs.kotlin.KotlinHardcodedPasswordEqualsDetector">
        <Details>将名为password的变量与常量值进行比较时，识别硬编码凭据。</Details>
    </Detector>


    <Detector class="com.h3xstream.findsecbugs.serial.FastJsonDeserializationDetector">
        <Details>对象反序列化检测器</Details>
    </Detector>

    <BugPattern type="FASTJSON_UNSAFE_DESERIALIZATION">
        <ShortDescription>不安全的FastJson反序列化配置</ShortDescription>
        <LongDescription>不安全的FastJson反序列化配置</LongDescription>
        <Details>
            <![CDATA[
            <p>
            <b>参考</b><br/>
            <a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315">fastjson在1.2.24以及之前版本存在远程代码执行高危安全漏洞</a><br/>
            </p>
            ]]>
        </Details>
    </BugPattern>
    <BugCode abbrev="SECFSDES">FastJson反序列化使用不安全。</BugCode>


</MessageCollection>
